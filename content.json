{"meta":{"title":"雨泪漂古 | 过往云烟","subtitle":null,"description":"陈晨，PHP开发工程师，现就职于新浪乐居。","author":"Jsyz Chen","url":"http://jayzchen.com"},"pages":[{"title":"Friend List","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"friend-list/index-1.html","permalink":"http://jayzchen.com/friend-list/index-1.html","excerpt":"","text":"[ln_friend]"},{"title":"Friend List","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"friend-list/index.html","permalink":"http://jayzchen.com/friend-list/index.html","excerpt":"","text":"[ln_friend]"},{"title":"Inbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"inbox/index-1.html","permalink":"http://jayzchen.com/inbox/index-1.html","excerpt":"","text":"[lnpm_inbox]"},{"title":"Inbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"inbox/index.html","permalink":"http://jayzchen.com/inbox/index.html","excerpt":"","text":"[lnpm_inbox]"},{"title":"Inbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"inbox/index-2.html","permalink":"http://jayzchen.com/inbox/index-2.html","excerpt":"","text":"[lnpm_inbox]"},{"title":"Notification","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"notification/index-2.html","permalink":"http://jayzchen.com/notification/index-2.html","excerpt":"","text":"[ln_notifications_overview]"},{"title":"Notification","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"notification/index-1.html","permalink":"http://jayzchen.com/notification/index-1.html","excerpt":"","text":"[ln_notifications_overview]"},{"title":"Friend List","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"friend-list/index-2.html","permalink":"http://jayzchen.com/friend-list/index-2.html","excerpt":"","text":"[ln_friend]"},{"title":"Notification","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"notification/index.html","permalink":"http://jayzchen.com/notification/index.html","excerpt":"","text":"[ln_notifications_overview]"},{"title":"Outbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"outbox/index-1.html","permalink":"http://jayzchen.com/outbox/index-1.html","excerpt":"","text":"[lnpm_outbox]"},{"title":"Outbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"outbox/index-2.html","permalink":"http://jayzchen.com/outbox/index-2.html","excerpt":"","text":"[lnpm_outbox]"},{"title":"Outbox","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"outbox/index.html","permalink":"http://jayzchen.com/outbox/index.html","excerpt":"","text":"[lnpm_outbox]"},{"title":"Award","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"award/index-2.html","permalink":"http://jayzchen.com/award/index-2.html","excerpt":"","text":"[award_list]"},{"title":"Award","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"award/index-1.html","permalink":"http://jayzchen.com/award/index-1.html","excerpt":"","text":"[award_list]"},{"title":"Award","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"award/index.html","permalink":"http://jayzchen.com/award/index.html","excerpt":"","text":"[award_list]"},{"title":"Edit Profile","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"edit-profile/index-1.html","permalink":"http://jayzchen.com/edit-profile/index-1.html","excerpt":"","text":"[edit_profile]"},{"title":"Edit Profile","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"edit-profile/index.html","permalink":"http://jayzchen.com/edit-profile/index.html","excerpt":"","text":"[edit_profile]"},{"title":"Send Message","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:09:42.000Z","comments":true,"path":"send-message/index-1.html","permalink":"http://jayzchen.com/send-message/index-1.html","excerpt":"","text":"[lnpm_send]"},{"title":"Edit Profile","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"edit-profile/index-2.html","permalink":"http://jayzchen.com/edit-profile/index-2.html","excerpt":"","text":"[edit_profile]"},{"title":"Send Message","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T11:03:57.000Z","comments":true,"path":"send-message/index.html","permalink":"http://jayzchen.com/send-message/index.html","excerpt":"","text":"[lnpm_send]"},{"title":"Send Message","date":"2016-01-27T15:43:27.000Z","updated":"2016-04-26T14:13:50.000Z","comments":true,"path":"send-message/index-2.html","permalink":"http://jayzchen.com/send-message/index-2.html","excerpt":"","text":"[lnpm_send]"}],"posts":[{"title":"搭建Git服务器","slug":"set-up-git-server","date":"2017-04-07T16:00:00.000Z","updated":"2017-04-11T01:05:17.000Z","comments":true,"path":"2017/04/08/set-up-git-server/","link":"","permalink":"http://jayzchen.com/2017/04/08/set-up-git-server/","excerpt":"搭建Git服务器需要准备一台运行Linux的机器，我们这使用CentOS。 安装git12$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel$ sudo yum install git 创建一个git用户，用来运行git服务1$ sudo adduser git","text":"搭建Git服务器需要准备一台运行Linux的机器，我们这使用CentOS。 安装git12$ sudo yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel$ sudo yum install git 创建一个git用户，用来运行git服务1$ sudo adduser git 创建证书登录我们需要为系统用户 git 的 authorized_keys 文件添加一些开发者 SSH 公钥。收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个 创建authorized_keys文件1234$ su git$ cd$ mkdir .ssh &amp;&amp; chmod 700 .ssh$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys 客户端上生成密钥12$ cd$ ssh-keygen -t rsa 执行完后，会生成id_rsa、id_rsa.pub这两个文件，其中id_rsa.pub是公钥，id_rsa是密钥 导入公钥注意，要远程copy成authorized_keys文件1$ scp ~/.ssh/id_rsa.pub root@server_ip:/home/git/.ssh/authorized_keys 初始化Git仓库新建一个裸仓库。一个远程仓库通常只是一个裸仓库（bare repository）— 即一个没有当前工作目录的仓库。 因为该仓库仅仅作为合作媒介，不需要从磁碟检查快照；存放的只有 Git 的资料。 简单的说，裸仓库就是你工程目录内的 .git 子目录内容，不包含其他资料。可以借助带 –bare 选项的 git init 命令来做到这一点，该命令在初始化仓库时不会创建工作目录。123$ cd /home/git/repo/$ sudo git init --bare sample.git$ sudo chown -R git:git sample.git 禁用shell登录借助一个名为 git-shell 的受限 shell 工具，你可以方便地将用户 git 的活动限制在与 Git 相关的范围内。该工具随 Git 软件包一同提供。 如果将 git-shell 设置为用户 git 的登录 shell（login shell），那么用户 git 便不能获得此服务器的普通 shell 访问权限。 若要使用 git-shell，需要用它替换掉 bash 或 csh，使其成为系统用户的登录 shell。 为进行上述操作，首先你必须确保 git-shell 已存在于 /etc/shells 文件中：123$ cat /etc/shells # see if `git-shell` is already in there. If not...$ which git-shell # make sure git-shell is installed on your system.$ sudo vim /etc/shells # and add the path to git-shell from last command 使用 chsh 命令修改任一系统用户的 shell1$ sudo chsh git # and enter the path to git-shell, usually: /usr/bin/git-shell 这样，用户 git 就只能利用 SSH 连接对 Git 仓库进行推送和拉取操作，而不能登录机器并取得普通 shell。 如果试图登录，你会发现尝试被拒绝，像这样：1234$ ssh git@gitserverfatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access.Connection to gitserver closed. 克隆远程仓库现在，客户端可以通过git clone命令克隆远程仓库了，在各自的电脑上运行1$ git clone git@server_ip:/home/git/repo/sample.git 然后就可以开始使用git服务器了,推送，别的用户可以拉取，协同工作1234$ touch index.html$ git add index.html$ git commit index.html -m 'first commit'$ git push origin master 同步部署网站创建网站的目录12$ sudo mkdir /var/www/sample -p$ sudo chown -R git:git /var/www/sample 设置git钩子12$ cd /home/git/repo/sample.git/hooks$ sudo vim post-receive 写入以下内容：12#!/bin/shGIT_WORK_TREE=/var/www/sample git checkout -f 写入权限1$ sudo chmod +x post-receive 如果是要同步多台服务器，可以在钩子里添加rsync的脚本。","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://jayzchen.com/tags/linux/"},{"name":"git","slug":"git","permalink":"http://jayzchen.com/tags/git/"}]},{"title":"yaf-example","slug":"yaf-example","date":"2016-10-22T15:04:58.000Z","updated":"2017-04-10T14:44:21.000Z","comments":true,"path":"2016/10/22/yaf-example/","link":"","permalink":"http://jayzchen.com/2016/10/22/yaf-example/","excerpt":"yaf是鸟哥用C语言编写的一个PHP框架，yaf文档地址：http://yaf.laruence.com/manual/ 其实很早之前就接触yaf了,但只是学习学习，没有深入的去了解和使用，但由于最近在重构一个项目，而重构所用到的框架就是yaf框架，正好趁此机会好好地使用了下yaf框架。本篇文章其实主要给一个yaf的例子,就是扩展了下yaf，因为yaf的东西本身就简单，所以快。鸟哥也给了两个例子，laruence/yaf-examples,一个是在yaf里使用Smarty的例子，还有一个是在yaf里加了DB和Log操作的包的例子。我给的yaf例子地址是：https://github.com/jsyzchen/chen-yaf","text":"yaf是鸟哥用C语言编写的一个PHP框架，yaf文档地址：http://yaf.laruence.com/manual/ 其实很早之前就接触yaf了,但只是学习学习，没有深入的去了解和使用，但由于最近在重构一个项目，而重构所用到的框架就是yaf框架，正好趁此机会好好地使用了下yaf框架。本篇文章其实主要给一个yaf的例子,就是扩展了下yaf，因为yaf的东西本身就简单，所以快。鸟哥也给了两个例子，laruence/yaf-examples,一个是在yaf里使用Smarty的例子，还有一个是在yaf里加了DB和Log操作的包的例子。我给的yaf例子地址是：https://github.com/jsyzchen/chen-yaf 配置首先，你得安装yaf,文档里有，http://php.net/manual/zh/yaf.installation.php 。安装完之后，编辑php.ini文件，配置yaf:123extension=yaf.soyaf.use_namespace=1 ;开启命名空间yaf.use_spl_autoload=1 ;开启自动加载 chen-yaf主要添加了: Eloquent ORM Twig 罗飞的SocketLog 一些常用函数 先编辑conf/application.ini文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[common]application.directory = APP_PATH \"/application\"application.view.ext = \"html\"application.view.engine = \"twig\";useruser.default_filter = 'trim,addslashes,htmlspecialchars'[product : common];twigtwig.cache = APP_PATH \"/storage/twig/cache\";databasedatabase.driver = 'mysql'database.read.host = '127.0.0.1'database.write.host = '127.0.0.1'database.port = '3306'database.database = 'test'database.username = 'root'database.password = '123456'database.charset = 'utf8'database.collation = 'utf8_unicode_ci'database.prefix = ''database.strict = false[develop : common]application.dispatcher.catchException = TRUE;twigtwig.debug = true;socketlogsocketlog.enable = truesocketlog.host = 'localhost'socketlog.optimize = truesocketlog.show_included_files = truesocketlog.error_handler = truesocketlog.force_client_ids = ''socketlog.allow_client_ids = 'slog_78de03';databasedatabase.driver = 'mysql'database.host = '127.0.0.1'database.port = '3306'database.database = 'test'database.username = 'root'database.password = '123456'database.charset = 'utf8'database.collation = 'utf8_unicode_ci'database.prefix = ''database.strict = false database为MySql数据库的配置,socketlog为socketlog的配置，twig为twig模板引擎的配置 因为chen-yaf使用的是composer包，首先你得安装composer,然后在项目目录下建一个composer.json文件，内容如下：12345678910111213141516&#123; \"require\": &#123; \"php\": \"&gt;=5.5.9\", \"illuminate/database\": \"5.1.*\", \"illuminate/events\": \"5.1.*\", \"symfony/debug\": \"2.6.*\", \"symfony/var-dumper\": \"2.6.*\", \"twig/twig\": \"^1.26\" &#125;, \"autoload\": &#123; \"psr-4\": &#123; \"App\\\\Models\\\\\": \"application/models\" &#125; &#125;&#125; 然后记得1composer install 编辑Bootstrap.php文件12345678910111213141516/** * 加载vendor下的文件 */public function _initLoader()&#123; \\Yaf\\Loader::import(APP_PATH . '/vendor/autoload.php');&#125;/** * 配置 */public function _initConfig()&#123; $this-&gt;config = \\Yaf\\Application::app()-&gt;getConfig();//把配置保存起来 \\Yaf\\Registry::set('config', $this-&gt;config);&#125; Eloquent ORM Eloquent ORM是Laravel框架里的ORM。 yaf里是没有数据库操作类的，可以自己写一个DAO层，或者直接使用第三方包，推荐Medoo和Eloquent ORM,chen-yaf里面是使用的Eloquent ORM。编辑Bootstrap.php文件，添加_initDefaultDbAdapter方法1234567891011121314151617/** * 初始化数据库分发器 * @function _initDefaultDbAdapter * @author jsyzchenchen@gmail.com */public function _initDefaultDbAdapter()&#123; //初始化 illuminate/database $capsule = new \\Illuminate\\Database\\Capsule\\Manager; $capsule-&gt;addConnection($this-&gt;config-&gt;database-&gt;toArray()); $capsule-&gt;setEventDispatcher(new \\Illuminate\\Events\\Dispatcher(new \\Illuminate\\Container\\Container)); $capsule-&gt;setAsGlobal(); //开启Eloquent ORM $capsule-&gt;bootEloquent(); class_alias('\\Illuminate\\Database\\Capsule\\Manager', 'DB');&#125; 然后在application/model下建一个Model基类，EloquentModel.php123456789&lt;?phpnamespace App\\Models;use Illuminate\\Database\\Eloquent\\Model;class EloquentModel extends Model&#123;&#125; 然后所有的Model类都继承EloquentModel，这样就可以像在Laravel里操作数据库了，另外DB也是能使用的，和Laravel里的DB facade使用方法一样。文档：https://laravel-china.org/docs/5.1/eloquent , https://laravel-china.org/docs/5.1/database twig twig是Symfony框架里的模板引擎，当然它也可以单独使用。模板引擎也可以使用Smarty,如果你想拥有页面缓存的功能，请用Smarty。 编辑Bootstrap.php文件，添加_initTwig方法123456789/** * Twig View * @param \\Yaf\\Dispatcher $dispatcher */public function _initTwig(\\Yaf\\Dispatcher $dispatcher)&#123; $twig = new \\Twig\\Adapter(APP_PATH . \"/application/views/\", $this-&gt;config-&gt;get(\"twig\")-&gt;toArray()); $dispatcher-&gt;setView($twig);&#125; 这样就可以在html文件里使用twig模板引擎了 SocketLog SocketLog是ThinkPHP框架核心开发者“罗飞”开发的一个调试的工具，使用过ThinkPHP5框架的应该很熟悉。更多的介绍可以阅读我的另一篇文章：日志服务。 我把SocketLog相关的文件放在library/Common/Logger目录下了，当你安装完SocketLog并配置好，在Bootstrap.php添加_initLogger方法。12345678910111213141516/** * 日志 * @param \\Yaf\\Dispatcher $dispatcher */public function _initLogger(\\Yaf\\Dispatcher $dispatcher)&#123; //SocketLog if (Yaf\\ENVIRON === 'develop') &#123; if ($this-&gt;config-&gt;socketlog-&gt;enable) &#123; //载入 \\Yaf\\Loader::import('Common/Logger/slog.function.php'); //配置SocketLog slog($this-&gt;config-&gt;socketlog-&gt;toArray(),'config'); &#125; &#125;&#125; 然后就可以在Chrome里调试你的代码了。 其他chen-yaf引入了一些函数，放在library/Common/functions.php里了，都是一些常用的函数，如果你的项目中有其他的函数往里面加就行了。编辑Bootstrap.php,添加_initFunction方法。1234567/** * 公用函数载入 */public function _initFunction()&#123; \\Yaf\\Loader::import('Common/functions.php');&#125; 总结chen-yaf只是一个很简单的yaf例子，加了Eloquent ORM和twig。实际项目中，还需要不断地往里面添加东西。既然我们使用了composer包，那么我们在做自己的项目时就可以很方便的使用第三方包，避免我们重复造轮子。推荐一些第三方包吧，也是我们在重构项目里所用到的。1.carbon:对于时间日期的操作。2.php-resque:队列的操作。3.sokil/php-mongo:mongodb的操作。4.monolog:日志的操作。","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"yaf","slug":"yaf","permalink":"http://jayzchen.com/tags/yaf/"},{"name":"twig","slug":"twig","permalink":"http://jayzchen.com/tags/twig/"},{"name":"Eloquent","slug":"Eloquent","permalink":"http://jayzchen.com/tags/Eloquent/"},{"name":"composer","slug":"composer","permalink":"http://jayzchen.com/tags/composer/"}]},{"title":"centos下编译安装nginx1.10+mysql5.7+php7.0","slug":"install-nginx1.10-mysql5.7-php7.0","date":"2016-10-20T16:00:00.000Z","updated":"2017-04-10T14:45:55.000Z","comments":true,"path":"2016/10/21/install-nginx1.10-mysql5.7-php7.0/","link":"","permalink":"http://jayzchen.com/2016/10/21/install-nginx1.10-mysql5.7-php7.0/","excerpt":"一、准备编译环境关闭SELINUX修改配置文件，重启服务后永久生效1sed -i 's/SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config 命令行设置立即生效1setenforce 0","text":"一、准备编译环境关闭SELINUX修改配置文件，重启服务后永久生效1sed -i 's/SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config 命令行设置立即生效1setenforce 0 二、安装nginx1.101.安装编译工具和依赖包12yum -y install gcc gcc-c++ autoconf automake make cmakeyum -y install zlib zlib-devel openssl openssl-devel pcre-devel perl perl-devel perl-maExtUtils-Embed 2.新建nginx用户和用户组12sudo groupadd -r nginxsudo useradd -s /sbin/nologin -g nginx -r nginx 3.编译安装12wget http://nginx.org/download/nginx-1.10.2.tar.gztar -zxvf nginx-1.10.2.tar.gz 编译参数123456789101112131415161718192021./configure \\--user=nginx \\--group=nginx \\--prefix=/usr/local/nginx \\--sbin-path=/usr/sbin/nginx \\--conf-path=/etc/nginx/nginx.conf \\--error-log-path=/var/log/nginx/error.log \\--http-log-path=/var/log/nginx/access.log \\--pid-path=/var/run/nginx.pid \\--lock-path=/var/run/nginx.lock \\--with-http_ssl_module \\--with-http_realip_module \\--with-http_addition_module \\--with-http_sub_module \\--with-http_dav_module \\--with-http_flv_module \\--with-http_gzip_static_module \\--with-http_stub_status_module \\--with-http_perl_module \\--with-mail \\--with-mail_ssl_module 安装12makemake install 添加SysV启动脚本。1vim /etc/init.d/nginx 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#!/bin/sh # # nginx - this script starts and stops the nginx daemon # # chkconfig: - 85 15 # description: Nginx is an HTTP(S) server, HTTP(S) reverse \\ # proxy and IMAP/POP3 proxy server # processname: nginx # config: /etc/nginx/nginx.conf # config: /etc/sysconfig/nginx # pidfile: /var/run/nginx.pid # Source function library. . /etc/rc.d/init.d/functions# Source networking configuration. . /etc/sysconfig/network# Check that networking is up. [ \"$NETWORKING\" = \"no\" ] &amp;&amp; exit 0nginx=\"/usr/sbin/nginx\"prog=$(basename $nginx)NGINX_CONF_FILE=\"/etc/nginx/nginx.conf\"[ -f /etc/sysconfig/nginx ] &amp;&amp; . /etc/sysconfig/nginxlockfile=/var/lock/subsys/nginxstart() &#123; [ -x $nginx ] || exit 5 [ -f $NGINX_CONF_FILE ] || exit 6 echo -n $\"Starting $prog: \" daemon $nginx -c $NGINX_CONF_FILE retval=$? echo [ $retval -eq 0 ] &amp;&amp; touch $lockfile return $retval&#125;stop() &#123; echo -n $\"Stopping $prog: \" killproc $prog -QUIT retval=$? echo [ $retval -eq 0 ] &amp;&amp; rm -f $lockfile return $retvalkillall -9 nginx&#125;restart() &#123; configtest || return $? stop sleep 1 start&#125;reload() &#123; configtest || return $? echo -n $\"Reloading $prog: \" killproc $nginx -HUPRETVAL=$? echo &#125;force_reload() &#123; restart&#125;configtest() &#123;$nginx -t -c $NGINX_CONF_FILE&#125;rh_status() &#123; status $prog&#125;rh_status_q() &#123; rh_status &gt;/dev/null 2&gt;&amp;1&#125;case \"$1\" in start) rh_status_q &amp;&amp; exit 0 $1 ;; stop) rh_status_q || exit 0 $1 ;; restart|configtest) $1 ;; reload) rh_status_q || exit 7 $1 ;; force-reload) force_reload ;; status) rh_status ;; condrestart|try-restart) rh_status_q || exit 0 ;; *) echo $\"Usage: $0 &#123;start|stop|status|restart|condrestart|try-restart|reload|force-reload|configtest&#125;\" exit 2esac 赋予脚本执行权限1chmod +x /etc/init.d/nginx 添加至服务管理列表，设置开机自启。12chkconfig --add nginxchkconfig nginx on 启动服务1service nginx start 三、安装mysql5.7注：cmake安装mysql5.7，机器要好一点，一开始我的机器是1核1G内存，跑得卡死，后来换成2核4G内存没问题注：在CentOS 7.0版操作系统的最小安装完成后，在/etc目录下会存在一个my.cnf，需要将此文件更名为其他的名字，如：/etc/my.cnf.bak，否则，该文件会干扰源码安装的MySQL的正确配置，造成无法启动。 安装编译工具和依赖包1yum -y install make gcc-c++ cmake bison-devel ncurses-devel 添加mysql用户和用户组123groupadd mysqluseradd -s /sbin/nologin -g mysql mysqlid mysql 下载mysql123456cd /root/srcwget http://downloads.sourceforge.net/project/boost/boost/1.59.0/boost_1_59_0.tar.gzwget http://dev.mysql.com/Downloads/MySQL-5.7/mysql-5.7.11.tar.gztar zxvf boost_1_59_0.tar.gztar zxvf mysql-5.7.11.tar.gzcd mysql-5.7.11 cmake 参数 cmake 参数 含义 -DCMAKE_INSTALL_PREFIX=dir_name 设置mysql安装目录 -DMYSQL_UNIX_ADDR=file_name 设置监听套接字路径，这必须是一个绝对路径名。默认为/tmp/mysql.sock -DDEFAULT_CHARSET=charset_name 设置服务器的字符集。 -DDEFAULT_COLLATION=collation_name 设置服务器的排序规则。 -DWITH_INNOBASE_STORAGE_ENGINE = 1 存储引擎选项：MyISAM，MERGE，MEMORY，和CSV引擎是默认编译到服务器中，并不需要明确地安装。静态编译一个存储引擎到服务器，使用-DWITH_engine_STORAGE_ENGINE= 1 可用的存储引擎值有：ARCHIVE, BLACKHOLE, EXAMPLE, FEDERATED, INNOBASE (InnoDB), PARTITION (partitioning support), 和PERFSCHEMA (Performance Schema) -DMYSQL_DATADIR=dir_name 设置mysql数据库文件目录 -DMYSQL_TCP_PORT=port_num 设置mysql服务器监听端口，默认为3306 -DENABLE_DOWNLOADS=bool 是否要下载可选的文件。例如，启用此选项（设置为1），cmake将下载谷歌所使用的测试套件运行单元测试。 -DWITH_BOOST BOOST包的位置 cmake执行1234567891011121314151617cmake \\-DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\-DMYSQL_DATADIR=/usr/local/mysql/data \\-DSYSCONFDIR=/etc \\-DWITH_MYISAM_STORAGE_ENGINE=1 \\-DWITH_INNOBASE_STORAGE_ENGINE=1 \\-DWITH_MEMORY_STORAGE_ENGINE=1 \\-DWITH_READLINE=1 \\-DMYSQL_UNIX_ADDR=/tmp/mysql.sock \\-DMYSQL_TCP_PORT=3306 \\-DENABLED_LOCAL_INFILE=1 \\-DWITH_PARTITION_STORAGE_ENGINE=1 \\-DEXTRA_CHARSETS=all \\-DDEFAULT_CHARSET=utf8 \\-DDEFAULT_COLLATION=utf8_general_ci \\-DDOWNLOAD_BOOST=1 \\-DWITH_BOOST=/root/src/boost_1_59_0 安装12make make install 修改安装目录的属组为mysql1chown -R mysql:mysql /usr/local/mysql/ 拷贝配置文件和启动脚本123cp /usr/local/mysql/support-files/my-default.cnf /etc/my.cnfcp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqldchmod +x /etc/init.d/mysqld 设置开机自动启动12chkconfig mysqld on chkconfig --add mysqld 修改配置文件中的安装路径及数据目录存放路径1echo -e \"basedir = /usr/local/mysql\\ndatadir = /usr/local/mysql/data\\n\" &gt;&gt; /etc/my.cnf 设置PATH环境变量12echo \"export PATH=$PATH:/usr/local/mysql/bin\" &gt; /etc/profile.d/mysql.sh source /etc/profile.d/mysql.sh 初始化数据注：mysql7里mysql_install_db 已经不再推荐使用了，建议改成 mysqld –initialize 完成实例初始化。需要先确保 datadir 目标目录下是空的，避免误操作破坏已有数据1mysqld --user=mysql --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --initialize --initialize-insecure 启动服务1service mysqld start 设置mysql密码123mysql -uroot -puse mysql set password = password('1234abcd'); 四、安装php7.01、安装依赖包，我用的centos,偷下懒，直接yum安装1yum install -y gcc gcc-c++ make zlib zlib-devel pcre pcre-devel libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel glibc glibc-devel glib2 glib2-devel bzip2 bzip2-devel ncurses ncurses-devel curl curl-devel e2fsprogs e2fsprogs-devel krb5 krb5-devel openssl openssl-devel openldap openldap-devel nss_ldap openldap-clients openldap-servers libmcrypt libmcrypt-devel mhash mhash-devel 2、下载php7包1wget http://cn2.php.net/distributions/php-7.0.17.tar.gz 3、解压，进入PHP目录12tar zxvf php-7.0.17.tar.gzcd php-7.0.17 4、配置123456789101112131415161718192021222324252627282930313233./configure --prefix=/usr/local/php \\--with-config-file-path=/usr/local/php/etc \\--with-config-file-scan-dir=/usr/local/php/etc/conf.d \\--enable-mysqlnd \\--with-mysqli \\--with-pdo-mysql \\--with-gd \\--with-iconv \\--with-zlib \\--enable-xml \\--enable-bcmath \\--enable-shmop \\--enable-sysvsem \\--enable-fpm \\--enable-inline-optimization \\--enable-mbregex \\--enable-mbstring \\--enable-ftp \\--enable-gd-native-ttf \\--enable-opcache \\--with-openssl \\--enable-pcntl \\--enable-sockets \\--with-xmlrpc \\--enable-zip \\--enable-soap \\--without-pear \\--with-gettext \\--enable-session \\--with-mcrypt \\--with-curl \\--with-jpeg-dir \\--with-freetype-dir 5、安装12makemake install 6、添加php和php-fpm配置文件进入源码安装包1cp /root/src/php-7.0.17/php.ini-production /usr/local/php/etc/php.ini 1234cd /usr/local/php/etccp php-fpm.conf.default php-fpm.confcp php-fpm.d/www.conf.default php-fpm.d/www.confsed -i 's@;pid = run/php-fpm.pid@pid = /usr/local/php/var/run/php-fpm.pid@' php-fpm.conf 7、设置PATH环境变量12echo \"export PATH=$PATH:/usr/local/php/bin\" &gt; /etc/profile.d/php.shsource /etc/profile.d/php.sh 8、添加php-fpm启动脚本12cp /root/src/php-7.0.17/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpmchmod +x /etc/init.d/php-fpm 9、添加php-fpm至服务列表并设置开机自启123chkconfig --add php-fpm chkconfig --list php-fpm chkconfig php-fpm on 10、启动服务1service php-fpm start","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"linux","slug":"linux","permalink":"http://jayzchen.com/tags/linux/"},{"name":"mysql","slug":"mysql","permalink":"http://jayzchen.com/tags/mysql/"},{"name":"nginx","slug":"nginx","permalink":"http://jayzchen.com/tags/nginx/"}]},{"title":"日志服务","slug":"log-service","date":"2016-07-28T14:38:00.000Z","updated":"2017-04-10T14:46:10.000Z","comments":true,"path":"2016/07/28/log-service/","link":"","permalink":"http://jayzchen.com/2016/07/28/log-service/","excerpt":"一、SocketLog前言 前言：ThinkPHP框架的页面Trace 配置：&#39;SHOW_PAGE_TRACE&#39;=&gt;1 在页面的右下角能够看到新版的页面Trace的默认显示区域（其中默认会显示当前页面的执行时间）。点击该区域，就会弹出详细的页面Trace信息，如图：","text":"一、SocketLog前言 前言：ThinkPHP框架的页面Trace 配置：&#39;SHOW_PAGE_TRACE&#39;=&gt;1 在页面的右下角能够看到新版的页面Trace的默认显示区域（其中默认会显示当前页面的执行时间）。点击该区域，就会弹出详细的页面Trace信息，如图： 默认情况下，会包含基本、文件、流程、错误、SQL和调试 几个选项卡，点击不同的选项卡会切换显示不同的页面Trace信息。 文件选项卡会列出当前页面加载的文件信息，并且会列出文件的大小。 流程选项卡是当前页面执行的行为信息记录 错误选项卡是当前页面所有的错误信息记录，为了方便，该示例模拟了一些错误信息。 SQL选项卡则显示了当前页面所有执行过的sql语句 调试选项卡则显示当前页面的调试信息，主要是通过trace方法来进行调试输出的。 SocketLog简介 Author:ThinkPHP框架核心开发者-罗飞项目Github url：https://github.com/luofei614/SocketLog SocketLog适合Ajax调试和API调试， 举一个常见的场景，用SocketLog来做微信调试， 我们在做微信API开发的时候，如果API有bug，微信只提示“改公众账号暂时无法提供服务，请稍候再试” ，我们根本不知道API出来什么问题。 有了SocketLog就不一样了， 我们可以知道微信给API传递了哪些参数， 程序有错误我们也能看见错误信息 正在运行的API有bug，不能var_dump进行调试，因为会影响client的调用。 将日志写到文件，查看也不方便，特别是带调用栈或大数据结构的文件日志，查看日志十分困难。 这时候用SocketLog最好，SocketLog通过websocket将调试日志打印到浏览器的console中。你还可以用它来分析开源程序，分析SQL性能，结合taint分析程序漏洞。 使用方法 首先，请在chrome浏览器上安装好插件。 https://chrome.google.com/webstore/detail/socketlog/apkmbfpihjhongonfcgdagliaglghcod 安装服务端npm install -g socketlog-server , 运行命令 socketlog-server 即可启动服务。 将会在本地起一个websocket服务 ，监听端口是1229 。 如果想服务后台运行： socketlog-server &gt; /dev/null &amp; 我们提供公用的服务端，需要去申请client_id : http://111.202.76.133/ 如果你的服务器有防火墙，请开启1229和1116两个端口，这两个端口是socketlog要使用的。 在自己的程序中发送日志： 1234&lt;?phpinclude './php/slog.function.php';slog('hello world');?&gt; 用slog函数发送日志， 支持多种日志类型：slog(‘msg’,’log’); //一般日志slog(‘msg’,’error’); //错误日志slog(‘msg’,’info’); //信息日志slog(‘msg’,’warn’); //警告日志slog(‘msg’,’trace’);// 输入日志同时会打出调用栈slog(‘msg’,’alert’);//将日志以alert方式弹出slog(‘msg’,’log’,’color:red;font-size:20px;’);//自定义日志的样式，第三个参数为css样式 通过上面例子可以看出， slog函数支持三个参数：第一个参数是日志内容，日志内容不光能支持字符串哟，大家如果传递数组,对象等一样可以打印到console中。第二个参数是日志类型，可选，如果没有指定日志类型默认类型为log， 第三个参数是自定样式，在这里写上你自定义css样式即可。 配置 在载入slog.function.php文件后，还可以对SocketLog进行一些配置。 例如：我们如果想将程序的报错信息页输出到console，可以配置 12345678&lt;?phpinclude './php/slog.function.php';slog(array( 'error_handler'=&gt;true),'config');echo notice;//制造一个notice报错slog('这里是输出的一般日志');?&gt; 配置SocketLog也是用slog函数， 第一个参数传递配置项的数组，第二个参数设置为config 还支持其他配置项 123456789101112&lt;?phpinclude './php/slog.function.php';slog(array( 'enable'=&gt;true,//是否打印日志的开关 'host'=&gt;'localhost',//websocket服务器地址，默认localhost 'optimize'=&gt;false,//是否显示利于优化的参数，如果运行时间，消耗内存等，默认为false 'show_included_files'=&gt;false,//是否显示本次程序运行加载了哪些文件，默认为false 'error_handler'=&gt;false,//是否接管程序错误，将程序错误显示在console中，默认为false 'force_client_id'=&gt;'',//日志强制记录到配置的client_id,默认为空 'allow_client_ids'=&gt;array()////限制允许读取日志的client_id，默认为空,表示所有人都可以获得日志。),'config');?&gt; optimize 参数如果设置为true， 可以在日志中看见利于优化参数，如：[运行时间：0.081346035003662s][吞吐率：12.29req/s][内存消耗：346,910.45kb] show_included_files 设置为true，能显示出程序运行时加载了哪些文件，比如我们在分析开源程序时，如果不知道模板文件在那里， 往往看一下加载文件列表就知道模板文件在哪里了。 error_handler 设置为true，能接管报错，将错误信息显示到浏览器console， 在开发程序时notice报错能让我们快速发现bug，但是有些notice报错是不可避免的，如果让他们显示在页面中会影响网页的正常布局，那么就设置error_handler,让它显示在浏览器console中吧。 另外此功能结合php taint也是极佳的。 taint能自动检测出xss，sql注入， 如果只用php taint， 它warning报错只告诉了变量输出的地方，并不知道变量在那里赋值、怎么传递。通过SocketLog， 能看到调用栈，轻松对有问题变量进行跟踪。 更多taint的信息：http://www.laruence.com/2012/02/14/2544.html error_handler 原理1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 接管报错 */public static function registerErrorHandler()&#123; if(!self::check()) &#123; return ; &#125; set_error_handler(array(__CLASS__,'error_handler')); register_shutdown_function(array(__CLASS__,'fatalError'));&#125;public static function fatalError()&#123; // 保存日志记录 if ($e = error_get_last()) &#123; self::error_handler($e['type'],$e['message'],$e['file'],$e['line']); self::sendLog();//此类终止不会调用类的 __destruct 方法，所以此处手动sendLog &#125;&#125;public static function error_handler($errno, $errstr, $errfile, $errline)&#123; switch($errno)&#123; case E_WARNING: $severity = 'E_WARNING'; break; case E_NOTICE: $severity = 'E_NOTICE'; break; case E_USER_ERROR: $severity = 'E_USER_ERROR'; break; case E_USER_WARNING: $severity = 'E_USER_WARNING'; break; case E_USER_NOTICE: $severity = 'E_USER_NOTICE'; break; case E_STRICT: $severity = 'E_STRICT'; break; case E_RECOVERABLE_ERROR: $severity = 'E_RECOVERABLE_ERROR'; break; case E_DEPRECATED: $severity = 'E_DEPRECATED'; break; case E_USER_DEPRECATED: $severity = 'E_USER_DEPRECATED'; break; case E_ERROR: $severity = 'E_ERR'; break; case E_PARSE: $severity = 'E_PARSE'; break; case E_CORE_ERROR: $severity = 'E_CORE_ERROR'; break; case E_COMPILE_ERROR: $severity = 'E_COMPILE_ERROR'; break; case E_USER_ERROR: $severity = 'E_USER_ERROR'; break; default: $severity= 'E_UNKNOWN_ERROR_'.$errno; break; &#125; $msg=\"&#123;$severity&#125;: &#123;$errstr&#125; in &#123;$errfile&#125; on line &#123;$errline&#125; -- SocketLog error handler\"; self::trace($msg,2,self::$css['error_handler']);&#125; 设置client_id: 在chrome浏览器中，可以设置插件的Client_ID ，Client_ID是你任意指定的字符串。 设置client_id后能实现以下功能：1，配置allow_client_ids 配置项，让指定的浏览器才能获得日志，这样就可以把调试代码带上线。 普通用户访问不会触发调试，不会发送日志。 开发人员访问就能看的调试日志， 这样利于找线上bug。 Client_ID 建议设置为姓名拼命加上随机字符串，这样如果有员工离职可以将其对应的client_id从配置项allow_client_ids中移除。 client_id除了姓名拼音，加上随机字符串的目的，以防别人根据你公司员工姓名猜测出client_id,获取线上的调试日志。设置allow_client_ids示例代码： 1234&lt;?phpslog(array('allow_client_ids'=&gt;array('luofei_zfH5NbLn','easy_DJq0z80H')),'set_config') 2, 设置force_client_id配置项，让后台脚本也能输出日志到chrome。 网站有可能用了队列，一些业务逻辑通过后台脚本处理， 如果后台脚本需要调试，你也可以将日志打印到浏览器的console中， 当然后台脚本不和浏览器接触，不知道当前触发程序的是哪个浏览器，所以我们需要强制将日志打印到指定client_id的浏览器上面。 我们在后台脚本中使用SocketLog时设置force_client_id 配置项指定要强制输出浏览器的client_id 即可。示例代码: 123456&lt;?phpinclude './php/slog.function.php';slog(array( 'force_client_id'=&gt;'luofei_zfH5NbLn'),'config');slog('test'); 对数据库进行调试SocketLog还能对sql语句进行调试，自动对sql语句进行explain分析，显示出有性能问题的sql语句。sql语句字体较大，是因为它有性能问题， 在sql语句的后台已经标注Using filesort。 我们还可以点击某个sql语句看到sql执行的调用栈，清楚的知道sql语句是如何被执行的，方便我们分析程序、方便做开源程序的二次开发。用slog函数打印sql语句是，第二个参数传递为mysql或mysqli的对象即可。 示例代码：12345&lt;?php$link=mysql_connect( 'localhost:3306' , 'root' , '123456' , true ) ;mysql_select_db('kuaijianli',$link);$sql=\"SELECT * FROM `user`\";slog($sql,$link); 通过上面的方法，socketlog还能自动为你检测没有where语句的sql操作，然后自动提示你。 注意，有时候在数据比较少的情况下，mysql查询不会使用索引，explain也会提示Using filesort等性能问题， 其实这时候并不是真正有性能问题， 你需要自行进行判断，或者增加更多的数据再测试。 对API进行调试 网站调用了API ，如何将API程序的调试信息也打印到浏览器的console中？ 前面我们讲了一个配置 force_client_id， 能将日志强制记录到指定的浏览器。 用这种方式也可以将API的调试信息打印到console中，但是force_client_id 只能指定一个client_id， 如果我们的开发环境是多人共用，这种方式就不方便了。 其实只要将浏览器传递给网站的User-Agent 再传递给API， API程序中不用配置force_client_id， 也能识别当前访问程序的浏览器， 将日志打印到当前访问程序的浏览器， 我们需要将SDK代码稍微做一下修改。 调用API的SDK，一般是用curl写的，增加下面代码可以将浏览器的User-Agent传递到API 。 1234567891011&lt;?php$headers=array();if(isset($_SERVER['HTTP_USER_AGENT']))&#123; $headers[]='User-Agent: '.$_SERVER['HTTP_USER_AGENT'];&#125;if(isset($_SERVER['HTTP_SOCKETLOG']))&#123; $headers[]='Socketlog: '.$_SERVER['HTTP_SOCKETLOG'];&#125;curl_setopt($ch,CURLOPT_HTTPHEADER,$headers); 二、SeasLog简介为什么使用SeasLoglog日志，通常是系统或软件、应用的运行记录。通过log的分析，可以方便用户了解系统或软件、应用的运行情况；如果你的应用log足够丰富，也可以分析以往用户的操作行为、类型喜好、地域分布或其他更多信息；如果一个应用的log同时也分了多个级别，那么可以很轻易地分析得到该应用的健康状况，及时发现问题并快速定位、解决问题，补救损失。php内置error_log、syslog函数功能强大且性能极好，但由于各种缺陷(error_log无错误级别、无固定格式，syslog不分模块、与系统日志混合)，灵活度降低了很多，不能满足应用需求。 好消息是，有不少第三方的log类库弥补了上述缺陷，如log4php、plog、Analog等(当然也有很多应用在项目中自己开发的log类)。其中以log4php最为著名，设计精良、格式完美、文档完善、功能强大。推荐。不过log4php在性能方面表现非常差,下图是SeasLog与log4php的ab并发性能测试( 测试环境:Ubuntu12.04单机,CPU I3,内存 16G,硬盘 SATA 7200): 那么有没有一种log类库满足以下需求呢： 分模块、分级别 配置简单(最好是勿须配置) 日志格式清晰易读 应用简单、性能很棒 目前提供了什么 在PHP项目中便捷、规范地记录log 可配置的默认log目录与模块 指定log目录与获取当前配置 初步的分析预警框架 高效的日志缓冲、便捷的缓冲debug 遵循 PSR-3 日志接口规范 自动记录错误信息 自动记录异常信息 连接TCP端口发送 连接UDP端口发送 目标是怎样的 便捷、规范的log记录 高效的海量log分析 可配置、多途径的log预警 安装编译安装 SeasLog123$ /path/to/phpize$ ./configure --with-php-config=/path/to/php-config$ make &amp;&amp; make install PECL安装SeasLog1$ pecl install seaslog Windows环境中使用SeasLog到PECL/SeasLog主页找到对应的dll进行安装 PECL/SeasLog Windows Dll seaslog.ini的配置123456789101112131415; configuration for php SeasLog moduleextension = seaslog.soseaslog.default_basepath = /log/seaslog-test ;默认log根目录seaslog.default_logger = default ;默认logger目录seaslog.disting_type = 1 ;是否以type分文件 1是 0否(默认)seaslog.disting_by_hour = 1 ;是否每小时划分一个文件 1是 0否(默认)seaslog.use_buffer = 1 ;是否启用buffer 1是 0否(默认)seaslog.buffer_size = 100 ;buffer中缓冲数量 默认0(不使用buffer_size)seaslog.level = 0 ;记录日志级别 默认0(所有日志)seaslog.trace_error = 1 ;自动记录错误 默认1(开启)seaslog.trace_exception = 0 ;自动记录异常信息 默认0(关闭)seaslog.default_datetime_format = &quot;Y:m:d H:i:s&quot; ;日期格式配置 默认&quot;Y:m:d H:i:s&quot;seaslog.appender = 1 ;日志存储介质 1File 2TCP 3UDP (默认为1)seaslog.remote_host = 127.0.0.1 ;接收ip 默认127.0.0.1 (当使用TCP或UDP时必填)seaslog.remote_port = 514 ;接收端口 默认514 (当使用TCP或UDP时必填) seaslog.disting_type = 1 开启以type分文件，即log文件区分info\\warn\\erro seaslog.disting_by_hour = 1 开启每小时划分一个文件 seaslog.use_buffer = 1 开启buffer。默认关闭。当开启此项时，日志预存于内存，当请求结束时(或异常退出时)一次写入文件。 seaslog.buffer_size = 100 设置缓冲数量为100. 默认为0,即无缓冲数量限制.当buffer_size大于0时,缓冲量达到该值则写一次文件. seaslog.level = 3 记录的日志级别.默认为0,即所有日志均记录。当level为1时,关注debug以上级别(包括debug)，以此类推。level大于8时，所有日志均不记录。 使用常量与函数常量列表SeasLog 共将日志分成8个级别 SEASLOG_DEBUG “debug” SEASLOG_INFO “info” SEASLOG_NOTICE “notice” SEASLOG_WARNING “warning” SEASLOG_ERROR “error” SEASLOG_CRITICAL “critical” SEASLOG_ALERT “alert” SEASLOG_EMERGENCY “emergency”123456var_dump(SEASLOG_DEBUG,SEASLOG_INFO,SEASLOG_NOTICE);/*string('debug') debug级别string('info') info级别string('notice') notice级别*/ 函数列表SeasLog 提供了这样一组函数，可以方便地获取与设置根目录、模块目录、快速写入与统计log。相信从下述伪代码的注释中，您可以快速获取函数信息，具体使用将紧接其后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237&lt;?php/** * @author neeke@php.net * Date: 14-1-27 下午4:47 */class SeasLog&#123; public function __construct() &#123; #SeasLog init &#125; public function __destruct() &#123; #SeasLog distroy &#125; /** * 设置basePath * * @param $basePath * * @return bool */ static public function setBasePath($basePath) &#123; return TRUE; &#125; /** * 获取basePath * * @return string */ static public function getBasePath() &#123; return 'the base_path'; &#125; /** * 设置模块目录 * @param $module * * @return bool */ static public function setLogger($module) &#123; return TRUE; &#125; /** * 获取最后一次设置的模块目录 * @return string */ static public function getLastLogger() &#123; return 'the lastLogger'; &#125; /** * 设置DatetimeFormat配置 * @param $format * * @return bool */ static public function setDatetimeFormat($format) &#123; return TRUE; &#125; /** * 返回当前DatetimeFormat配置格式 * @return string */ static public function getDatetimeFormat() &#123; return 'the datetimeFormat'; &#125; /** * 统计所有类型（或单个类型）行数 * @param string $level * @param string $log_path * @param null $key_word * * @return array | long */ static public function analyzerCount($level = 'all', $log_path = '*', $key_word = NULL) &#123; return array(); &#125; /** * 以数组形式，快速取出某类型log的各行详情 * * @param $level * @param string $log_path * @param null $key_word * @param int $start * @param int $limit * @param $order 默认为正序 SEASLOG_DETAIL_ORDER_ASC，可选倒序 SEASLOG_DETAIL_ORDER_DESC * * @return array */ static public function analyzerDetail($level = SEASLOG_INFO, $log_path = '*', $key_word = NULL, $start = 1, $limit = 20, $order = SEASLOG_DETAIL_ORDER_ASC) &#123; return array(); &#125; /** * 获得当前日志buffer中的内容 * * @return array */ static public function getBuffer() &#123; return array(); &#125; /** * 将buffer中的日志立刻刷到硬盘 * * @return bool */ static public function flushBuffer() &#123; return TRUE; &#125; /** * 记录debug日志 * * @param $message * @param array $content * @param string $module */ static public function debug($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_DEBUG &#125; /** * 记录info日志 * * @param $message * @param array $content * @param string $module */ static public function info($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_INFO &#125; /** * 记录notice日志 * * @param $message * @param array $content * @param string $module */ static public function notice($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_NOTICE &#125; /** * 记录warning日志 * * @param $message * @param array $content * @param string $module */ static public function warning($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_WARNING &#125; /** * 记录error日志 * * @param $message * @param array $content * @param string $module */ static public function error($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_ERROR &#125; /** * 记录critical日志 * * @param $message * @param array $content * @param string $module */ static public function critical($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_CRITICAL &#125; /** * 记录alert日志 * * @param $message * @param array $content * @param string $module */ static public function alert($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_ALERT &#125; /** * 记录emergency日志 * * @param $message * @param array $content * @param string $module */ static public function emergency($message, array $content = array(), $module = '') &#123; #$level = SEASLOG_EMERGENCY &#125; /** * 通用日志方法 * @param $level * @param $message * @param array $content * @param string $module */ static public function log($level, $message, array $content = array(), $module = '') &#123; &#125;&#125; SeasLog Logger的使用获取与设置basePath1234567891011$basePath_1 = SeasLog::getBasePath();SeasLog::setBasePath('/log/base_test');$basePath_2 = SeasLog::getBasePath();var_dump($basePath_1,$basePath_2);/*string(19) \"/log/seaslog-ciogao\"string(14) \"/log/base_test\"*/ 直接使用 SeasLog::getBasePath()，将获取php.ini(seaslog.ini)中设置的 seaslog.default_basepath 的值。 使用 SeasLog::setBasePath() 函数，将改变 SeasLog::getBasePath() 的取值。 设置logger与获取lastLogger12345678910$lastLogger_1 = SeasLog::getLastLogger();SeasLog::setLogger('testModule/app1');$lastLogger_2 = SeasLog::getLastLogger();var_dump($lastLogger_1,$lastLogger_2);/*string(7) \"default\"string(15) \"testModule/app1\"*/ 与basePath相类似的， 直接使用 SeasLog::getLastLogger()，将获取php.ini(seaslog.ini)中设置的 seaslog.default_logger 的值。 使用 SeasLog::setLogger() 函数，将改变 SeasLog::getLastLogger() 的取值。 快速写入log上面已经设置过了basePath与logger，于是log记录的目录已经产生了， log记录目录 = basePath / logger / {fileName}.loglog文件名，以 年月日 分文件，如今天是2014年02月18日期，那么 {fileName} = 20140218; 还记得 php.ini 中设置的 seaslog.disting_type 吗？ 默认的 seaslog.disting_type = 0，如果今天我使用了 SeasLog ，那么将产生最终的log文件： LogFile = basePath / logger / 20140218.log 如果 seaslog.disting_type = 1，则最终的log文件将是这样的三个文件 infoLogFile = basePath / logger / INFO.20140218.log warnLogFile = basePath / logger / WARN.20140218.log erroLogFile = basePath / logger / ERRO.20140218.log 1234567891011121314151617181920212223242526SeasLog::log(SEASLOG_ERROR,'this is a error test by ::log');SeasLog::debug('this is a &#123;userName&#125; debug',array('&#123;userName&#125;' =&gt; 'neeke'));SeasLog::info('this is a info log');SeasLog::notice('this is a notice log');SeasLog::warning('your &#123;website&#125; was down,please &#123;action&#125; it ASAP!',array('&#123;website&#125;' =&gt; 'github.com','&#123;action&#125;' =&gt; 'rboot'));SeasLog::error('a error log');SeasLog::critical('some thing was critical');SeasLog::alert('yes this is a &#123;messageName&#125;',array('&#123;messageName&#125;' =&gt; 'alertMSG'));SeasLog::emergency('Just now, the house next door was completely burnt out! &#123;note&#125;',array('&#123;note&#125;' =&gt; 'it`s a joke'));/*这些函数同时也接受第3个参数为logger的设置项注意，当last_logger == 'default'时等同于:SeasLog::setLogger('test/new/path');SeasLog::error('test error 3');如果已经在前文使用过SeasLog::setLogger()函数，第3个参数的log只在此处临时使用，不影响下文。*/ log格式统一为： {type} | {pid} | {timeStamp} |{dateTime} | {logInfo} 12345678error | 23625 | 1406422432.786 | 2014:07:27 08:53:52 | this is a error test by logdebug | 23625 | 1406422432.786 | 2014:07:27 08:53:52 | this is a neeke debuginfo | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | this is a info lognotice | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | this is a notice logwarning | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | your github.com was down,please rboot it ASAP!error | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | a error logcritical | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | some thing was criticalemergency | 23625 | 1406422432.787 | 2014:07:27 08:53:52 | Just now, the house next door was completely burnt out! it is a joke 当seaslog.appender配置为 2（TCP） 或 3（UDP） 时，日志将推送至remote_host:remote_port的TCP或UDP端口 此时log格式统一为 {hostName} | {loggerName} | {type} | {pid} | {timeStamp} |{dateTime} | {logInfo} 123456789vagrant-ubuntu-trusty | test/logger | error | 21423 | 1466787583.321 | 2016:06:25 00:59:43 | this is a error test by ::log vagrant-ubuntu-trusty | test/logger | debug | 21423 | 1466787583.322 | 2016:06:25 00:59:43 | this is a neeke debug vagrant-ubuntu-trusty | test/logger | info | 21423 | 1466787583.323 | 2016:06:25 00:59:43 | this is a info log vagrant-ubuntu-trusty | test/logger | notice | 21423 | 1466787583.324 | 2016:06:25 00:59:43 | this is a notice log vagrant-ubuntu-trusty | test/logger | warning | 21423 | 1466787583.325 | 2016:06:25 00:59:43 | your github.com was down,please rboot it ASAP! vagrant-ubuntu-trusty | test/logger | error | 21423 | 1466787583.326 | 2016:06:25 00:59:43 | a error log vagrant-ubuntu-trusty | test/logger | critical | 21423 | 1466787583.327 | 2016:06:25 00:59:43 | some thing was critical vagrant-ubuntu-trusty | test/logger | alert | 21423 | 1466787583.328 | 2016:06:25 00:59:43 | yes this is a alertMSG vagrant-ubuntu-trusty | test/logger | emergency | 21423 | 1466787583.329 | 2016:06:25 00:59:43 | Just now, the house next door was completely burnt out! it`s a joke SeasLog Analyzer的使用快速统计某类型log的count值SeasLog在扩展中使用管道调用shell命令 grep -wc快速地取得count值，并返回值(array || int)给PHP。 1234567891011121314151617181920212223242526$countResult_1 = SeasLog::analyzerCount();$countResult_2 = SeasLog::analyzerCount(SEASLOG_WARNING);$countResult_3 = SeasLog::analyzerCount(SEASLOG_ERROR,date('Ymd',time()));var_dump($countResult_1,$countResult_2,$countResult_3);/*array(8) &#123; [\"debug\"]=&gt; int(3) [\"info\"]=&gt; int(3) [\"notice\"]=&gt; int(3) [\"warning\"]=&gt; int(3) [\"error\"]=&gt; int(6) [\"critical\"]=&gt; int(3) [\"alert\"]=&gt; int(3) [\"emergency\"]=&gt; int(3)&#125;int(7)int(1)*/ 获取某类型log列表SeasLog在扩展中使用管道调用shell命令 grep -w快速地取得列表，并返回array给PHP。 12345678910111213141516171819202122232425262728293031$detailErrorArray_inAll = SeasLog::analyzerDetail(SEASLOG_ERROR);$detailErrorArray_today = SeasLog::analyzerDetail(SEASLOG_ERROR,date('Ymd',time()));var_dump($detailErrorArray_inAll,$detailErrorArray_today);/*SeasLog::analyzerDetail(SEASLOG_ERROR) == SeasLog::analyzerDetail(SEASLOG_ERROR,'*');取当前模块下所有level为 SEASLOG_ERROR 的信息列表:array(6) &#123; [0] =&gt; string(66) \"error | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 \" [1] =&gt; string(66) \"error | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 \" [2] =&gt; string(66) \"error | 8620 | 1393172044.862 | 2014:02:24 00:14:04 | test error 3 \" [3] =&gt; string(66) \"error | 8646 | 1393172045.989 | 2014:02:24 00:14:05 | test error 3 \" [4] =&gt; string(66) \"error | 8672 | 1393172047.882 | 2014:02:24 00:14:07 | test error 3 \" [5] =&gt; string(66) \"error | 8698 | 1393172048.736 | 2014:02:24 00:14:08 | test error 3 \"&#125;SeasLog::analyzerDetail(SEASLOG_ERROR,date('Ymd',time()));只取得当前模块下，当前一天内,level为SEASLOG_ERROR 的信息列表:array(2) &#123; [0] =&gt; string(66) \"error | 8568 | 1393172042.717 | 2014:02:24 00:14:02 | test error 3 \" [1] =&gt; string(66) \"error | 8594 | 1393172044.104 | 2014:02:24 00:14:04 | test error 3 \"&#125;同理，取当月$detailErrorArray_mouth = SeasLog::analyzerDetail(SEASLOG_ERROR,date('Ym',time()));*/ 使用SeasLog进行健康预警预警的配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748[base]wait_analyz_log_path = /log/base_test[fork];是否开启多线程 1开启 0关闭fork_open = 1;线程个数fork_count = 3[warning]email[smtp_host] = smtp.163.comemail[smtp_port] = 25email[subject_pre] = 预警邮件 -email[smtp_user] = seaslogdemo@163.comemail[smtp_pwd] = seaslog#demoemail[mail_from] = seaslogdemo@163.comemail[mail_to] = gaochitao@weiboyi.comemail[mail_cc] = ciogao@gmail.comemail[mail_bcc] =[analyz]; enum; SEASLOG_DEBUG &quot;debug&quot;; SEASLOG_INFO &quot;info&quot;; SEASLOG_NOTICE &quot;notice&quot;; SEASLOG_WARNING &quot;warning&quot;; SEASLOG_ERROR &quot;error&quot;; SEASLOG_CRITICAL &quot;critical&quot;; SEASLOG_ALERT &quot;alert&quot;; SEASLOG_EMERGENCY &quot;emergency&quot;test1[module] = test/bbtest1[level] = SEASLOG_ERRORtest1[bar] = 1test1[mail_to] = gaochitao@weiboyi.comtest2[module] = 222test2[level] = SEASLOG_WARNINGtest3[module] = 333test3[level] = SEASLOG_CRITICALtest4[module] = 444test4[level] = SEASLOG_EMERGENCYtest5[module] = 555test5[level] = SEASLOG_DEBUG crontab配置12;每天凌晨3点执行0 3 * * * /path/to/php /path/to/SeasLog/Analyzer/SeasLogAnalyzer.php 扩展 默认SeasLog会将日志记录到文件，但是现在大多数应用都是集群，可能会出现某几台机器出现问题记录到了日志，但是查询的时候偏偏没从这几台查询，这样就会把问题漏掉，但是有解决方案，比如将日志存储的硬盘挂载到多个服务器上面或者直接使用阿里云的日志服务。如果需要将日志记录到更多存储介质，可以用rsyslog或ELK（Elasticsearch + Logstash + Kibana）搭建接口服务器，然后用TCP或UDP发送过去。 FaceBook的Scribe 链家网日志系统架构-Kafka 阿里云日志服务 三、MonologMonolog是PHP的一个日志类库。相比于其他的日志类库，它有以下的特点： 功能强大。可以把日志发送到文件、socket、邮箱、数据库和各种web services。 遵循PSR3的接口规范。可以很轻易的替换成其他遵循同一规范的日志类库。 良好的扩展性。通过Handler、Formatter和Processor这几个接口，可以对Monolog类库进行各种扩展和自定义。 框架集成 Frameworks and libraries using PSR-3can be used very easily with Monolog since it implements the interface. Symfony2 comes out of the box with Monolog. Silex comes out of the box with Monolog. Laravel 4 &amp; 5 come out of the box with Monolog. Lumen comes out of the box with Monolog. PPI comes out of the box with Monolog. CakePHP is usable with Monolog via the cakephp-monolog plugin. Slim is usable with Monolog via the Slim-Monolog log writer. XOOPS 2.6 comes out of the box with Monolog. Aura.Web_Project comes out of the box with Monolog. Nette Framework can be used with Monolog via Kdyby/Monolog extension. Proton Micro Framework comes out of the box with Monolog. 基本用法安装最新版本：composer require monolog/monolog要求PHP版本为5.3以上。 123456789101112&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\StreamHandler;// 创建日志频道$log = new Logger('name');$log-&gt;pushHandler(new StreamHandler('path/to/your.log', Logger::WARNING));// 添加日志记录$log-&gt;addWarning('Foo');$log-&gt;addError('Bar'); Monolog图解 核心概念 每一个Logger实例都包含一个频道名(channel)和handler的堆栈。当你添加一条记录时，记录会依次通过handler堆栈的处理。而每个handler也可以决定是否把记录传递到下一个堆栈里的下一个handler。 通过handler，我们可以实现一些复杂的日志操作。例如我们把StreamHandler放在堆栈的最下面，那么所有的日志记录最终都会写到硬盘文件里。同时我们把MailHandler放在堆栈的最上面，通过设置日志等级把错误日志通过邮件发送出去。Handler里有个$bubble属性，这个属性定义了handler是否拦截记录不让它流到下一个handler。所以如果我们把MailHandler的$bubble参数设置为false，则出现错误日志时，日志会通过MailHandler发送出去，而不会经过StreamHandler写到硬盘上。 Logger可以创建多个，每个都可以定义自己的频道名和handler堆栈。handler可以在多个Logger中共享。频道名会反映在日志里，方便我们查看和过滤日志记录。 如果没有指定日志格式（Formatter），Handler会使用默认的Formatter。 日志的等级不能自定义，目前使用的是RFC 5424里定义的8个等级：debug、info、notice、warning、error、critical、alert和emergency。如果对日志记录有其他的需求，可以通过Processo对日志记录添加内容。 日志等级 DEBUG (100): 详细的debug信息。 INFO (200): 关键事件,例如：用户登录和SQL记录。 NOTICE (250): 一般性重要的事件。 WARNING (300): 出现非错误的异常,例如：使用了被弃用的API、错误地使用了API或者非预想的不必要错误。 ERROR (400): 运行时错误,不需要立刻处理,但必须记录下来以备检测。 CRITICA (500): 严重错误,例如：程序组件不可用或者出现非预期的异常。 ALERT (550): 必须立刻采取行动,例如：在整个网站都垮掉了、数据库不可用了或者其他的情况下， 应该 发送一条警报短信把你叫醒。。 EMERGENCY (600): 系统不可用。 用法详解多个handler1234567891011121314&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\StreamHandler;use Monolog\\Handler\\FirePHPHandler;// 创建Logger实例$logger = new Logger('my_logger');// 添加handler$logger-&gt;pushHandler(new StreamHandler(__DIR__.'/my_app.log', Logger::DEBUG));$logger-&gt;pushHandler(new FirePHPHandler());// 开始使用$logger-&gt;addInfo('My logger is now ready'); 第一步我们先创建一个Logger实例，传入的是频道名，这个频道名可以用于区分多个Logger实例。 实例本身并不知道如何处理日志记录，它是通过handler进行处理的。handler可以设置多个，例如上面的例子设置了两个handler，可以对日志记录进行两种不同方式的处理。 需要注意的是，由于handler是采用堆栈的方式保存，所以后面添加的handler位于栈顶，会首先被调用。 添加额外的数据Monolog有两种方式对日志添加额外的信息。 使用上下文第一个方法是使用$context参数，传入一个数组：123&lt;?php$logger-&gt;addInfo('Adding a new user', array('username' =&gt; 'Seldaek')); 使用processor第二个方法是使用processor。processor可以是任何可调用的方法，这些方法把日志记录作为参数，然后经过处理修改extra部分后返回。1234567&lt;?php$logger-&gt;pushProcessor(function ($record) &#123; $record['extra']['dummy'] = 'Hello world!'; return $record;&#125;); Processor不一定要绑定在Logger实例上，也可以绑定到某个具体的handler上。使用handler实例的pushProcessor方法进行绑定。 频道的使用使用频道名可以对日志进行分类，这在大型的应用上是很有用的。通过频道名，可以很容易的对日志记录进行刷选。 例如我们想在同一个日志文件里记录不同模块的日志，我们可以把相同的handler绑定到不同的Logger实例上，这些实例使用不同的频道名：12345678910111213141516171819&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\StreamHandler;use Monolog\\Handler\\FirePHPHandler;// 创建handler$stream = new StreamHandler(__DIR__.'/my_app.log', Logger::DEBUG);$firephp = new FirePHPHandler();// 创建应用的主要logger$logger = new Logger('my_logger');$logger-&gt;pushHandler($stream);$logger-&gt;pushHandler($firephp);// 通过不同的频道名创建一个用于安全相关的logger$securityLogger = new Logger('security');$securityLogger-&gt;pushHandler($stream);$securityLogger-&gt;pushHandler($firephp); HandlerMonolog内置很多很实用的handler，它们几乎囊括了各种的使用场景，这里介绍一些使用的： StreamHandler：把记录写进PHP流，主要用于日志文件。 SyslogHandler：把记录写进syslog。 ErrorLogHandler：把记录写进PHP错误日志。 NativeMailerHandler：使用PHP的mail()函数发送日志记录。 SocketHandler：通过socket写日志。 1234567891011121314151617&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\SocketHandler;// Create the logger$logger = new Logger('my_logger');// Create the handler$handler = new SocketHandler('unix:///var/log/httpd_app_log.socket');$handler-&gt;setPersistent(true);// Now add the handler$logger-&gt;pushHandler($handler, Logger::DEBUG);// You can now use your logger$logger-&gt;addInfo('My logger is now ready'); AmqpHandler：把记录写进兼容amqp协议的服务。 BrowserConsoleHandler：把日志记录写到浏览器的控制台。由于是使用浏览器的console对象，需要看浏览器是否支持。 RedisHandler：把记录写进Redis。 MongoDBHandler：把记录写进Mongo。 ElasticSearchHandler：把记录写到ElasticSearch服务。 BufferHandler：允许我们把日志记录缓存起来一次性进行处理。更多的Handler请看 https://github.com/Seldaek/monolog#handlers。 使用MongoDBHandler1234567891011121314151617181920&lt;?php require __DIR__.'/vendor/autoload.php';use Monolog\\Logger;use Monolog\\Handler\\MongoDBHandler;// Create the logger $logger = new Logger('channel');// Now add some handlers$mongo = new MongoClient();$database = 'test';//相当于数据库$collection = 'cron_log';//相当于一张表$logger-&gt;pushHandler(new MongoDBHandler($mongo, $database, $collection));// You can now use your logger$log_info = array();$log_info['run_time'] = 11;$log_info['msg'] = 'success';$logger-&gt;addError('Adding a new user', array('username' =&gt; 'Seldaek')); 扩展handlerMonolog内置了很多handler，但是并不是所有场景都能覆盖到，有时需要自己去定制handler。写一个handler并不难，只需要实现Monolog\\Handler\\HandlerInterface这个接口即可。下面这个例子实现了把日志记录写到数据库里。我们不需要把接口里的方法全部实现一次，可以直接使用Monolog提供的抽象类AbstractProcessingHandler进行继承，实现里面的write方法即可。 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpuse Monolog\\Logger;use Monolog\\Handler\\AbstractProcessingHandler;class PDOHandler extends AbstractProcessingHandler&#123; private $initialized = false; private $pdo; private $statement; public function __construct(PDO $pdo, $level = Logger::DEBUG, $bubble = true) &#123; $this-&gt;pdo = $pdo; parent::__construct($level, $bubble); &#125; protected function write(array $record) &#123; if (!$this-&gt;initialized) &#123; $this-&gt;initialize(); &#125; $this-&gt;statement-&gt;execute(array( 'channel' =&gt; $record['channel'], 'level' =&gt; $record['level'], 'message' =&gt; $record['formatted'], 'time' =&gt; $record['datetime']-&gt;format('U'), )); &#125; private function initialize() &#123; $this-&gt;pdo-&gt;exec( 'CREATE TABLE IF NOT EXISTS monolog ' .'(channel VARCHAR(255), level INTEGER, message LONGTEXT, time INTEGER UNSIGNED)' ); $this-&gt;statement = $this-&gt;pdo-&gt;prepare( 'INSERT INTO monolog (channel, level, message, time) VALUES (:channel, :level, :message, :time)' ); &#125;&#125; 然后我们就可以使用它了：123456&lt;?php$logger-&gt;pushHandler(new PDOHandler(new PDO('sqlite:logs.sqlite'));// You can now use your logger$logger-&gt;addInfo('My logger is now ready'); Formatter同样的，这里介绍几个自带的Formatter： LineFormatter：把日志记录格式化成一行字符串。 HtmlFormatter：把日志记录格式化成HTML表格，主要用于邮件。 JsonFormatter：把日志记录编码成JSON格式。 LogstashFormatter：把日志记录格式化成logstash的事件JSON格式。 ElasticaFormatter：把日志记录格式化成ElasticSearch使用的数据格式。更多的Formatter请看 https://github.com/Seldaek/monolog#formatters。 Processor前面说过，Processor可以为日志记录添加额外的信息，Monolog也提供了一些很实用的processor： IntrospectionProcessor：增加当前脚本的文件名和类名等信息。 WebProcessor：增加当前请求的URI、请求方法和访问IP等信息。 MemoryUsageProcessor：增加当前内存使用情况信息。 MemoryPeakUsageProcessor：增加内存使用高峰时的信息。更多的Processor请看 https://github.com/Seldaek/monolog#processors。 扩展 可以将Socketlog对于错误的处理应用到Monolog 尝试使用Monolog的ChromePHPHandler和FirePHPHandler完成SocketLog的功能 总结 SocketLog适合Ajax调试和API调试 SeasLog适合单机应用的日志系统 Monolog适合将日志记录到多种存储介质的日志系统","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"linux","slug":"linux","permalink":"http://jayzchen.com/tags/linux/"},{"name":"SeasLog","slug":"SeasLog","permalink":"http://jayzchen.com/tags/SeasLog/"},{"name":"Monolog","slug":"Monolog","permalink":"http://jayzchen.com/tags/Monolog/"},{"name":"SocketLog","slug":"SocketLog","permalink":"http://jayzchen.com/tags/SocketLog/"}]},{"title":"接口验证","slug":"api-verify","date":"2016-05-14T15:26:00.000Z","updated":"2017-04-10T14:44:38.000Z","comments":true,"path":"2016/05/14/api-verify/","link":"","permalink":"http://jayzchen.com/2016/05/14/api-verify/","excerpt":"权限验证在开发中是经常遇到的，通常也是封装好的模块，如果我们是使用者，通常指需要一个标记特性或者配置一下就可以完成，但实际里面还是有许多东西值得我们去探究。有时候我们也会用一些开源的权限验证框架，不过能自己实现一遍就更好，自己开发的东西成就感（逼格）会更高一些。进入主题，本篇主要是介绍接口端的权限验证，这个部分每个项目都会用到，所以最好就是也把它插件化，放在Common中，新的项目就可以直接使用了。","text":"权限验证在开发中是经常遇到的，通常也是封装好的模块，如果我们是使用者，通常指需要一个标记特性或者配置一下就可以完成，但实际里面还是有许多东西值得我们去探究。有时候我们也会用一些开源的权限验证框架，不过能自己实现一遍就更好，自己开发的东西成就感（逼格）会更高一些。进入主题，本篇主要是介绍接口端的权限验证，这个部分每个项目都会用到，所以最好就是也把它插件化，放在Common中，新的项目就可以直接使用了。 参数解析：1.appkey用于给服务端找到对应的secretkey。有时候我们会分配多对appkey-secretkey，例如安卓分一对，ios分一对。2.noncestr 、timestamp是为了防止重放攻击的（Repaly Attacks），这是为了避免请求被窃取后，攻击者通过分析后破解后，再次发起恶意请求。参数timestamp时间戳是必须的，所谓时间戳是指从1970-1-1至当前的总秒数。我们规定一个时间，例如20分钟，超过20分钟就算过期，如果当前时间与这个时间戳的间隔超过20分钟，就拒绝。random不是必须的，但有了它也可以更好防止重放攻击，理论上来说，timestamp+noncestr 应该是唯一的，这个时候我们可以将其作为key缓存在redis，如果通过请求的timestamp+noncestr能在规定时间获取到，就拒绝。这里还有个问题，客户端与服务端时间不同步怎么办？这个可以要求客户端校正时间，或者把过期时间调大，例如30分钟才算过期，再或者可以使用网络时间。防止重放攻击也是很常见的，例如你可以把手机时间调到较早前一个时间，再使用手机银行，这个时候就会收到error了。3.sign签名是通过一定规则生成。服务端接收到请求后，先通过appkey找到secretkey，进行同样拼接后进行hash，再与请求的sign进行比较，不一致则拒绝。这里需要注意的是，虽然我们做了很多工作，但依然不能阻止请求被窃取；我把timestamp参与到sign的生成，因为timestamp在请求中是可见的，请求被窃取后它完全可以被修改并再次提交，如果我们把它参与到sign的生成，一旦修改，sign也就不一样了，提高了安全性。参数字符串是通过请求参数拼接生成的字符串，目的也是类似的，防止参数被篡改。例如有三个参数a=1,b=3,c=2，那么参数字符串为a=1&amp;b=3&amp;c=2，也可以通过将参数按值进行排序再拼接生成参数字符串 代码：请求端生成签名，并请求123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?php$timestamp = time();//当前时间戳$noncestr = generateNonceStr();//随机字符串$appkey = '6ba895293c27f610';$secretkey = 'hBvT8gnBPiPFJjGw80WLtryTNJH7u9IF';$param1 = 'xxx';$param2 = '129423';$signature = getSignature(compact('timestamp','noncestr','param1','param2'), $secretkey);$api_url = \"http://apiurl.com?appkey=&#123;$appkey&#125;&amp;param1=&#123;$param1&#125;&amp;param2=&#123;$param2&#125;&amp;timestamp=&#123;$timestamp&#125;&amp;noncestr=&#123;$noncestr&#125;&amp;signature=&#123;$signature&#125;&amp;return=json&amp;encode=utf-8\";//get or post api_url to get data//获取签名function getSignature($arrdata,$secretkey='',$method=\"sha1\") &#123; if (!function_exists($method)) return false; $newArray = array(); foreach($arrdata as $key =&gt; $value) &#123; array_push($newArray,(string)$value); &#125; sort($newArray,SORT_STRING);//value值进行字符串的字典序排序 ksort($arrdata);//按照键值排序 $paramstring = \"\"; foreach($arrdata as $key =&gt; $value) &#123; if(strlen($paramstring) == 0) $paramstring .= $key . \"=\" . $value; else $paramstring .= \"&amp;\" . $key . \"=\" . $value; &#125; $Sign = $method($paramstring.$secretkey.implode($newArray)); return $Sign;&#125;//获取随机字符串function generateNonceStr($length=16)&#123; // 密码字符集，可任意添加你需要的字符 $chars = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\"; $str = \"\"; for($i = 0; $i &lt; $length; $i++) &#123; $str .= $chars[mt_rand(0, strlen($chars) - 1)]; &#125; return $str;&#125; 服务端检验签名,并返回相关数据123456789101112131415161718192021222324252627&lt;?php//检验签名function checkSignature($arrdata=array(),$secretkey='',$signature='',$method=\"sha1\")&#123; if (!function_exists($method)) return false; $newArray = array(); foreach($arrdata as $key =&gt; $value) &#123; array_push($newArray,(string)$value); &#125; sort($newArray,SORT_STRING);//value值进行字符串的字典序排序 ksort($arrdata);//按照键值排序 $paramstring = \"\"; foreach($arrdata as $key =&gt; $value) &#123; if(strlen($paramstring) == 0) $paramstring .= $key . \"=\" . $value; else $paramstring .= \"&amp;\" . $key . \"=\" . $value; &#125; $Sign = $method($paramstring.$secretkey.implode($newArray)); if( $Sign == $signature )&#123; return true; &#125;else&#123; return false; &#125;&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"API","slug":"API","permalink":"http://jayzchen.com/tags/API/"}]},{"title":"博客从WordPress迁移到Hexo","slug":"blog-wordpress-to-hexo","date":"2016-04-30T08:49:30.000Z","updated":"2017-04-10T14:45:00.000Z","comments":true,"path":"2016/04/30/blog-wordpress-to-hexo/","link":"","permalink":"http://jayzchen.com/2016/04/30/blog-wordpress-to-hexo/","excerpt":"偶然的机会看到了Hexo，就深深被吸引了，加载速度快，支持Markdown,还支持部署到Github上。作为一位PHP程序员，之前的博客用的是PHP开发的WordPress,其实感觉WordPress也不错，找了个漂亮的WordPress模板，加上七牛的CDN缓存，速度上，还算满意。既然对WordPress感觉不错，那为什么要把博客从WordPress迁移到Hexo上呢。第一，好奇，以前就经常听说Node.js有多么多么好，要把PHP给替代掉什么的，虽然Node.js的作用只是用来生成静态页面的，但可以感觉到，生成速度的确快；第二，支持Makedown，早就想学习Makedown了，正好边写博客，边学Makedown；第三，支持部署到Github上，以前WordPress都是部署到阿里云的云服务器ECS上的，还单独买了一个云数据库RDS，一个月得一百多块的花销，现在可以免费地放在Github上，省了一百多块钱，何乐而不为呢，哈哈。。不罗嗦了，直接上步骤。。","text":"偶然的机会看到了Hexo，就深深被吸引了，加载速度快，支持Markdown,还支持部署到Github上。作为一位PHP程序员，之前的博客用的是PHP开发的WordPress,其实感觉WordPress也不错，找了个漂亮的WordPress模板，加上七牛的CDN缓存，速度上，还算满意。既然对WordPress感觉不错，那为什么要把博客从WordPress迁移到Hexo上呢。第一，好奇，以前就经常听说Node.js有多么多么好，要把PHP给替代掉什么的，虽然Node.js的作用只是用来生成静态页面的，但可以感觉到，生成速度的确快；第二，支持Makedown，早就想学习Makedown了，正好边写博客，边学Makedown；第三，支持部署到Github上，以前WordPress都是部署到阿里云的云服务器ECS上的，还单独买了一个云数据库RDS，一个月得一百多块的花销，现在可以免费地放在Github上，省了一百多块钱，何乐而不为呢，哈哈。。不罗嗦了，直接上步骤。。 配置环境1.安装Node.jsCentos之类的,yum install nodejs &amp;&amp; sudo yum install npmMac OS X系统,使用brew install node 安装一下如果需要源码安装，可以去Node官网下载,然后编译安装2.安装git和上面一样，yum或brew或源码安装一下，这里就不再多说。可以参考此文档:https://git-scm.com/book/en/v2/Getting-Started-Installing-Git 进去可以选择中文, 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。12npm install -g hexo-cli npm install hexo-server --save 使用Hexo12345npm install hexo-cli -ghexo init blogcd blognpm installhexo server 浏览器输入http://localhost:4000效果图如下: 更换主题与配置默认的主题不是特别好看，我们可以在Hexo官网的主题页选择自己喜欢的主题，我选的是yilia。1.安装1234cd bloggit clone https://github.com/litten/hexo-theme-yilia.git themes/yiliacd themes/yiliagit pull 2.主题修改配置修改blog目录下的 _config.yml ： theme: yilia 3.yilia配置12cd blog/theme/yiliavim _config.yml 然后根据里面的提示填写就行了，这里就不多说了。里面有个多说的配置，litten可能有点没说清楚，其实填写的是多说站点设置里的多说域名你填写的部分。我这里如下填写： duoshuo: jsyzchen 4.添加Share.js Share.js 一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等 编辑yilia目录下的_config.yml1234#是否开启分享share_jia: falseshare_addthis: falseshare_social: true #这里添加Share.js的开关 编辑yilia/layout/_partial/head.ejs文件，加入代码123&lt;% if (theme.share_social)&#123; %&gt;&lt;%- css('https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.13/css/share.min') %&gt;&lt;% &#125; %&gt; 进入yilia/layout/_partial/post目录，添加share_social.ejs文件,代码如下123456&lt;div style=\"padding:0 40px 10px;\"&gt; &lt;!-- social-share Button BEGIN --&gt; &lt;div class=\"social-share\"&gt;&lt;/div&gt; &lt;script src=\"https://cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.15/js/social-share.min.js\"&gt;&lt;/script&gt; &lt;!-- social-share Button END --&gt;&lt;/div&gt; 编辑yilia/layout/_partial/article.ejs文件，找到theme.share_jia和share_addthis的位置，把加载social-share的代码放在与他们同级的位置123&lt;% if (!index &amp;&amp; theme.share_social)&#123; %&gt;&lt;%- partial('post/share_social') %&gt;&lt;% &#125; %&gt; WordPress迁移现在我们将WordPress的文章迁移到Hexo，如果你不需要迁移，跳过即可。首先，安装 hexo-migrator-wordpress 插件。1npm install hexo-migrator-wordpress --save 在 WordPress 仪表盘中导出数据(“Tools” → “Export” → “WordPress”)（详情参考WP支持页面）。插件安装完成后，执行下列命令来迁移所有文章。source 可以是 WordPress 导出的文件路径或网址。1hexo migrate wordpress &lt;source&gt; 完成之后可以1hexo server 浏览器输入http://localhost:4000 查看效果 配置Github1.申请GitHubGitHub直接申请一下就好了。 2.新建Repository(仓库) 登陆Github账号后，点击右上角的“+”号按钮，选择“New repository” 在Create a new repository界面填写格式如下图所示: 用户名.github.io，固定写法 3.设置你的git用户名和密码 Git会根据用户的名字和邮箱来记录提交，GitHub也是用这些信息来做权限的处理。git config –global user.name”这里是你申请Github账号时的name”git config –global user.email”这里是你申请Github账号时的邮箱” 3.SSH配置 SSH配置，有些麻烦。可以参考此文档：https://git-scm.com/book/en/v2/GitHub-Account-Setup-and-Configuration,进去可以选择中文,还是比较详细的。4.部署 进入blog目录下,编辑 _config.yml，把下面的your_username换成你的github用户名，注意冒号后面有一空格。 deploy: type: git repo: https://github.com/your_username/your_username.github.io.git branch: master 部署代码到Github1.清除缓存文件 (db.json) 和已生成的静态文件 (public)。1hexo clean 2.生成静态文件1hexo generate 3.部署1hexo deploy 4.上面两个命令可以合起来1hexo d -g 如果你此时没有看到一大段执行代码，一般是SSH配置有误。如果成功了，你进入Github repository,就是your_username.github.io是有代码的此时，你在浏览器里输入http://your_username.github.io 就可以看到你的博客了 效果展示我的WordPress和Hexo博客对比图:1.原来的WordPress2.如今的Hexo怎么感觉变丑了呢，没事，能省钱就好了，哈哈。。 绑定域名虽然使用your_username.github.io可以直接访问博客，但如果你想用自己的域名打开博客。1.域名解析 进入你的域名解析管理控制台，设置主机记录@，类型A，到IP 192.30.252.153(GitHub IP)。我用的是万网,设置如下:2.GitHub设置 在github项目中，blog/source目录下,新建一个文件CNAME，文件中写出你要绑定的域名,比如我的是jsyzchen.com 3.部署更新文件12hexo cleanhexo g -d 然后在浏览器输入你绑定的域名就可以看到你的Hexo博客了 性能优化所谓的性能优化，也就是把能一些图片,js,css放入cdn里,这样的话加载速度会大大加快，我这里推荐的七牛云存储,它有免费的额度，一般像博客这样的系统文件不会超的，而且七牛的CDN挺不错的，加载速度挺快。至于如何设置，可以查看七牛的帮助文档，你可以使用七牛的镜像存储，这样你就不需要把你的文件一个一个地往七牛存了，你可能还需要改些你选择主题的源码，就是把它以前调的图片，js，css地址改为CDN的访问地址就行了，这里不在啰嗦了。 文档推荐1.Hexo官方文档: https://hexo.io/zh-cn/docs/2.Git文档,里面有Git介绍、安装和使用等等，GitHub讲解也有: https://git-scm.com/doc3.Node.js官网: https://nodejs.org4.MakeDown语法中文版: http://www.markdown.cn/ 参考文章1.HEXO+Github,搭建属于自己的博客2.hexo–搭建3.Hexo在github上构建免费的Web应用","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"Hexo","slug":"Hexo","permalink":"http://jayzchen.com/tags/Hexo/"},{"name":"WordPress","slug":"WordPress","permalink":"http://jayzchen.com/tags/WordPress/"},{"name":"Node","slug":"Node","permalink":"http://jayzchen.com/tags/Node/"},{"name":"git","slug":"git","permalink":"http://jayzchen.com/tags/git/"},{"name":"MarkDown","slug":"MarkDown","permalink":"http://jayzchen.com/tags/MarkDown/"}]},{"title":"Redis实现点赞功能","slug":"redis-upvote","date":"2016-03-17T12:12:04.000Z","updated":"2017-04-10T14:46:26.000Z","comments":true,"path":"2016/03/17/redis-upvote/","link":"","permalink":"http://jayzchen.com/2016/03/17/redis-upvote/","excerpt":"此文章用来向大家介绍如何使用Reids实现点赞或类似功能，从而达到读写点赞数速度快。","text":"此文章用来向大家介绍如何使用Reids实现点赞或类似功能，从而达到读写点赞数速度快。 1.PHP代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115&lt;?php $type = isset($_GET['type']) ? intval($_GET['type']) : 2;//类型，1为点赞，2为查询点赞数$uid = addcslashes($_GET['uid']);//用户id$ip = $_SERVER['REMOTE_ADDR'];//ip地址$blog_id = isset($_GET['blog_id']) ? intval($_GET['blog_id']) : '';//博客idif(empty($blog_id))&#123;//参数为空 $return_data = array( 'code' =&gt; 4, 'msg' =&gt; 'blog_id can not be empty!', ); return $return_data; die;&#125;$redis=new Redis();//Redis 实例化$redis-&gt;conncet('127.0.0.1', 6379);$redis_key = 'upvote';if($type === 1)&#123;//为点赞的 if(empty($uid))&#123;//uid参数不能为空 $return_data = array( 'code' =&gt; 4, 'msg' =&gt; 'uid can not be empty!', ); return $return_data; die; &#125; //TODO 防ip redis sorted set if(!$redis-&gt;exists($redis_key.'_fang_ip'))&#123; $redis-&gt;zadd($redis_key.'_fang_ip',0,$ip); &#125; $ip_count = $redis-&gt;zScore($redis_key.'_fang_ip',$ip); if($ip_count &amp;&amp; intval($ip_count)&gt;20)&#123; $return_data = array( 'code' =&gt; 3, 'msg' =&gt; 'ip dianzan num &amp;gt; 20', ); return $return_data; die; &#125;else&#123; $redis-&gt;zincrby($redis_key.'_fang_ip',1,$ip); &#125; //TODO 查看该用户是否存在 //先去redis里查 if(!$redis-&gt;sismember($redis_key.'_uid_is_exist',$uid))&#123; //不存在请求接口 $api_url = '';// $res = get_url($api_url); $arr_res = json_decode($res, true); if ($arr_res['code'] !== 0) &#123; $return_data = array( 'code' =&gt; 5, 'msg' =&gt; 'user is not exist!', ); return $return_data; die; &#125;else&#123; //存进redis set $redis-&gt;sadd($redis_key.'_uid_is_exist',$uid); &#125; &#125; //TODO 查看该用户是否点赞过该楼盘 redis set if($redis-&gt;sismember($redis_key.$blog_id.'_uid',$uid))&#123; $return_data = array( 'code' =&gt; 1, 'msg' =&gt; 'user has upvoted', ); &#125;else&#123; $redis-&gt;sadd($redis_key.$blog_id.'_uid',$uid);//添加该用户到列表 if($redis-&gt;zScore($redis_key,$blog_id) === false)&#123; $redis-&gt;zadd($redis_key,100,$blog_id);//展示点赞基数（100） &#125; $score = $redis-&gt;zIncrBy($redis_key,1,$blog_id);//该楼盘点赞数加1，并返回当前的 $return_data = array( 'code' =&gt; 0, 'msg' =&gt; 'success', 'data' =&gt; array( 'blog_id'=&gt; $blog_id, 'score'=&gt; $score ) ); &#125;&#125;else&#123;//查询点赞数 redis sorted set $score = $redis-&gt;zScore($redis_key,$blog_id); if($score == false)&#123; $score = 100; &#125; if($uid)&#123; if($redis-&gt;sismember($redis_key.$blog_id.'_uid',$uid))&#123;//查看该用户是否点赞过该楼盘 $status = 1;//已经点赞过 &#125;else&#123; $status = 0;//未点赞过 &#125; &#125;else&#123; $status = 0; &#125; $return_data = array( 'code' =&gt; 0, 'msg' =&gt; 'success', 'data' =&gt; array( 'blog_id'=&gt; $blog_id, 'score'=&gt; $score, 'status'=&gt; $status ) );&#125;return $return_data; 2.cron，定时更新数据库的数据,并从Redis删除存储ip的key12345678910111213141516171819202122232425262728293031323334&lt;?php// 引入mysql 类,实例化$db = new cls_mysql();$redis=new Redis();//Redis 实例化$redis-&gt;conncet('127.0.0.1', 6379);$redis_key = 'upvote';//如果连不上redis，下次更新$redis-&gt;del($redis_key.'_fang_ip');//删除存储ip的key,一天删除一次$count = $redis-&gt;zCard($redis_key);$members = $redis-&gt;zRange($redis_key,0,$count-1);//取出所有元素$insert_sql = \"insert into upvote (blog_id,score) values \";$is_has_insert = false;//是否有插入数据foreach($members as $member)&#123; $score = $redis-&gt;zScore($redis_key,$member); $blog_id = $member; $sql = \"select blog_id from upvote where blog_id='&#123;$blog_id&#125;'\";//暂时使用索引覆盖,数量多了 TODO $res = $db-&gt;query($sql,true); if($res)&#123;//有数据时更新 $sql = \"update upvote set score='&#123;$score&#125;' where blog_id='&#123;$blog_id&#125;'\"; $db-&gt;query($sql); &#125;else&#123;//没数据时添加 $insert_sql .= \" ('&#123;$blog_id&#125;','&#123;$score&#125;'),\"; $is_has_insert = true; &#125;&#125;if($is_has_insert === true)&#123;//如果有插入数据 $insert_sql = trim($insert_sql, ','); $db-&gt;query($insert_sql);&#125;","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"redis","slug":"redis","permalink":"http://jayzchen.com/tags/redis/"}]},{"title":"AngularJs结合Yar构建一款email小应用","slug":"angularjs-yar-email","date":"2015-07-21T10:33:56.000Z","updated":"2017-04-10T14:44:31.000Z","comments":true,"path":"2015/07/21/angularjs-yar-email/","link":"","permalink":"http://jayzchen.com/2015/07/21/angularjs-yar-email/","excerpt":"注意:本文默认读者有一定的Angularjs和Yar的基础知识,Yar的基础案例之前的文章有分享过，AngularJs我以后也会写一篇文章简单介绍和应用一下。 一、AngularJs项目目录结构如下图","text":"注意:本文默认读者有一定的Angularjs和Yar的基础知识,Yar的基础案例之前的文章有分享过，AngularJs我以后也会写一篇文章简单介绍和应用一下。 一、AngularJs项目目录结构如下图 二、angularjs部分 1.index.html123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" ng-app='AMail'&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;link rel=\"stylesheet\" href=\"//lib.sinaapp.com/js/bootstrap/3.0.0/css/bootstrap.min.css\"&gt; &lt;script type=\"text/javascript\" src=\"//lib.sinaapp.com/js/angular.js/angular-1.2.19/angular.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"//lib.sinaapp.com/js/angular.js/angular-1.2.19/angular-route.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"scripts/controllers/controllers.js\"&gt;&lt;/script&gt; &lt;title&gt;AMail&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;A-Mail&lt;/h1&gt; &lt;div ng-view&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 2.list.html123456789101112&lt;table class=\"table table-hover\"&gt; &lt;tr&gt; &lt;td&gt;&lt;strong&gt;Sender&lt;/strong&gt;&lt;/td&gt; &lt;td&gt;&lt;strong&gt;Subject&lt;/strong&gt;&lt;/td&gt; &lt;td&gt;&lt;strong&gt;Date&lt;/strong&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr ng-repeat=\"message in messages\"&gt; &lt;td&gt;&#123;&#123;message.sender&#125;&#125;&lt;/td&gt; &lt;td&gt;&lt;a href=\"#/view/&#123;&#123;message.id&#125;&#125;\"&gt;&#123;&#123;message.subject&#125;&#125;&lt;/a&gt;&lt;/td&gt; &lt;td&gt;&#123;&#123;message.date&#125;&#125;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 3.detail.html123456789&lt;div&gt;&lt;strong&gt;Subject&lt;/strong&gt;&#123;&#123;message.subject&#125;&#125;&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Sender&lt;/strong&gt;&#123;&#123;message.sender&#125;&#125;&lt;/div&gt;&lt;div&gt;&lt;strong&gt;Date&lt;/strong&gt;&#123;&#123;message.date&#125;&#125;&lt;/div&gt;&lt;div&gt; &lt;strong&gt;To:&lt;/strong&gt; &lt;span ng-repeat=\"recipient in message.recipients\"&gt;&#123;&#123;recipient&#125;&#125;&lt;/span&gt; &lt;div&gt;&#123;&#123;message.message&#125;&#125;&lt;/div&gt; &lt;a href=\"#/\"&gt;Back to message list&lt;/a&gt;&lt;/div&gt; 4.controllers.js12345678910111213141516171819202122232425262728293031323334353637//为核心的AMail服务创建模块var aMailServices = angular.module('AMail',['ngRoute']);//在URL、模板和控制器之间建立映射关系function emailRouteConfig($routeProvider)&#123; $routeProvider.when('/', &#123; controller: ListController, templateUrl: 'views/list.html' &#125;). //注意,为了创建详情视图，我们在id前面加了一个冒号,从而指定了一个参数化的URL组件 when('/view/:id',&#123; controller: DetailController, templateUrl: 'views/detail.html' &#125;). otherwise(&#123; redirectTo: '/' &#125;);&#125;//配置我们的路由，以便AMail服务能够找到它aMailServices.config(emailRouteConfig);//把我们的邮件发布给邮件列表模板function ListController($scope,$http)&#123; $http.post( 'http://angularjs.jsyzchen.com/api/client.php', &#123;method: 'lst'&#125; ).success(function(data, status, headers, config)&#123; $scope.messages = data; &#125;);&#125;//从路由信息（从URL中解析出来的）中获取邮件id，然后用它找到正确的邮件对象function DetailController($scope, $routeParams,$http)&#123; $http.post( 'http://angularjs.jsyzchen.com/api/client.php', &#123;method: 'lst'&#125; ).success(function(data, status, headers, config)&#123; $scope.message = data[$routeParams.id]; &#125;); &#125; 三、Yar的API部分 1.server.php12345678910111213141516171819202122232425&lt;?phpclass API &#123; public function lst($parameter, $option = \"foo\") &#123; //假设$arr是从数据库里取出来的数据 $arr = array( array('id'=&gt;0,'sender'=&gt;'chenchenjsyz@163.com','subject'=&gt;'你好，我的老朋友！', 'date'=&gt;'2015-6-30','recipients'=&gt;array('chen.920925@hotmail.com'), 'message'=&gt;'中国江苏网7月20日讯 苏通大桥通车至今已有8年' ), array('id'=&gt;1,'sender'=&gt;'dslxs@163.com','subject'=&gt;'hello,my old friends!', 'date'=&gt;'2015-6-30','recipients'=&gt;array('chen.920925@hotmail.com'), 'message'=&gt;'江苏省教育考试院今天公布了文理类本二批次各院校的投档线' ), array('id'=&gt; 2, 'sender'=&gt;'test@163.com', 'subject'=&gt; '你好，my old friends！', 'date'=&gt; '2014-3-10', 'recipients'=&gt;array('chen.920925@hotmail.com'), 'message'=&gt;'环卫工、送报工、送奶工，遍布城市各处，' ) ); return json_encode($arr); &#125; protected function client_can_not_see() &#123; &#125;&#125;$service = new Yar_Server(new API());//创建一个HTTP RPC Server$service-&gt;handle();//启动HTTP RPC Server 2.client.php12345678910111213141516171819202122232425&lt;?phpheader ( \"content-type:text/html; charset=utf-8\" );error_reporting(E_ALL);$json_data = file_get_contents('php://input');$data = json_decode($json_data,true);$method = $data['method'];$parameters = $data['parameters'];if(empty($parameters))&#123; $parameters = array();&#125;//并行化调用function callback($retval, $callinfo) &#123; if ($callinfo == NULL) &#123; //做本地的逻辑 &#125; else&#123; echo($retval); &#125; &#125;function error_callback($type, $error, $callinfo) &#123; error_log($error);&#125;//Yar_Concurrent_Client::call — 注册一个并行的服务调用Yar_Concurrent_Client::call(\"http://angularjs.jsyzchen.com/api/server.php\", $method, $parameters, \"callback\");/* 发送所有注册的调用, 等待返回, 返回后Yar会调用callback回掉函数 */Yar_Concurrent_Client::loop(\"callback\",'error_callback'); //send,发送所有注册的并行调用 四、运行效果 1.列表页2.详细页","categories":[],"tags":[{"name":"angularjs","slug":"angularjs","permalink":"http://jayzchen.com/tags/angularjs/"},{"name":"javascript","slug":"javascript","permalink":"http://jayzchen.com/tags/javascript/"},{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"yar","slug":"yar","permalink":"http://jayzchen.com/tags/yar/"}]},{"title":"Yar初使用","slug":"yar-first-use","date":"2015-07-17T10:03:40.000Z","updated":"2017-04-10T14:47:04.000Z","comments":true,"path":"2015/07/17/yar-first-use/","link":"","permalink":"http://jayzchen.com/2015/07/17/yar-first-use/","excerpt":"Yar是鸟哥开发的一个并行的RPC框架，用来做API再合适不过了，对于Yar的介绍可以参考鸟哥的博客：http://www.laruence.com/2012/09/15/2779.html下面切入正题： 一、准备工作 1.安装msgpack扩展下载：http://pecl.php.net/package/msgpack，然后上传到/usr/local目录下，安装完可以删了。123456cd /usr/localtar zxvf msgpack-x.x.x.tgzcd msgpack-0.x.xphpize./configure - -with-php-config=/usr/local/php/bin/php-config #这里是你php的安装目录+/bin/php-config,下同make &amp;&amp; make install 会在no-debug-non-zts-xxxxxxxx中生成msgpack.so在php.ini中加入extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-xxxxxxxx/msgback.so","text":"Yar是鸟哥开发的一个并行的RPC框架，用来做API再合适不过了，对于Yar的介绍可以参考鸟哥的博客：http://www.laruence.com/2012/09/15/2779.html下面切入正题： 一、准备工作 1.安装msgpack扩展下载：http://pecl.php.net/package/msgpack，然后上传到/usr/local目录下，安装完可以删了。123456cd /usr/localtar zxvf msgpack-x.x.x.tgzcd msgpack-0.x.xphpize./configure - -with-php-config=/usr/local/php/bin/php-config #这里是你php的安装目录+/bin/php-config,下同make &amp;&amp; make install 会在no-debug-non-zts-xxxxxxxx中生成msgpack.so在php.ini中加入extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-xxxxxxxx/msgback.so 2.安装Yar扩展下载：http://pecl.php.net/package/yar 123456cd /usr/localtar zxvf yar-1.2.4.tgzcd yar-1.2.4phpize./configure - -with-php-config=/usr/local/php/bin/php-configmake &amp;&amp; make install 会在no-debug-non-zts-xxxxxxxx中生成yar.so在php.ini中加入extension=/usr/local/php/lib/php/extensions/no-debug-non-zts-xxxxxxxx/yar.so 3.重启php或apache 二、实例 1.server端代码,server.php1234567891011&lt;?phpclass API &#123; public function api($parameter, $option = \"foo\") &#123; $arr = array('code'=&gt;200,'msg'=&gt;'成功','data'=&gt;'返回数据'); return json_encode($arr); &#125; protected function client_can_not_see() &#123; &#125;&#125; $service = new Yar_Server(new API());$service-&gt;handle(); 2.get请求server端时，会显示接口文档 3.客户端代码，client.php12345678910111213141516171819&lt;?phperror_reporting(E_ALL);//简单的串行调用$client = new Yar_Client(\"http://yar.jsyzchen.com/server.php\");$result = $client-&gt;api(\"parameter\");//并行化调用function callback($retval, $callinfo) &#123; if ($callinfo == NULL) &#123; //做本地的逻辑 return TRUE; &#125; echo \"method: \" , $callinfo['method'] , \" result: \", $retval , \"\\n\";&#125;Yar_Concurrent_Client::call(\"http://yar.jsyzchen.com/server.php\", \"api\", array(\"parameters\"), \"callback\");Yar_Concurrent_Client::call(\"http://yar.jsyzchen.com/server.php\", \"api\", array(\"parameters\"), \"callback\");Yar_Concurrent_Client::call(\"http://yar.jsyzchen.com/server.php\", \"api\", array(\"parameters\"), \"callback\");Yar_Concurrent_Client::call(\"http://yar.jsyzchen.com/server.php\", \"api\", array(\"parameters\"), \"callback\");/* 发送所有注册的调用, 等待返回, 返回后Yar会调用callback回掉函数 */Yar_Concurrent_Client::loop(); //send 4.客户端显示 三、更多Yar文档请参考http://php.net/manual/zh/book.yar.php","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"yar","slug":"yar","permalink":"http://jayzchen.com/tags/yar/"}]},{"title":"rsync实现多台linux服务器的文件同步","slug":"rsync-linux-sync-file","date":"2015-05-10T15:44:34.000Z","updated":"2017-04-10T14:46:35.000Z","comments":true,"path":"2015/05/10/rsync-linux-sync-file/","link":"","permalink":"http://jayzchen.com/2015/05/10/rsync-linux-sync-file/","excerpt":"最近在搞阿里云的SLB，但是阿里云没有提供WEB服务器的文件同步，还好rsync可以实现，但弄了好久，所以希望阿里云能够早日出想新浪SAE的自动同步功能，或者出一个针对ESC的rsync配置视频或文档也好啊，让我们这些小白少走些弯路。好了，废话少说，我们来学习一下rsync的配置。","text":"最近在搞阿里云的SLB，但是阿里云没有提供WEB服务器的文件同步，还好rsync可以实现，但弄了好久，所以希望阿里云能够早日出想新浪SAE的自动同步功能，或者出一个针对ESC的rsync配置视频或文档也好啊，让我们这些小白少走些弯路。好了，废话少说，我们来学习一下rsync的配置。 目的是想从rsync服务端（10.171.88.115）的文件同步到rsync客户端(10.172.222.246),这里的ip地址是ECS的内网地址 一、首先安装rsync,怎样安装都行，rpm,yum，还是你用源码安装都可以。因为我用的是阿里云的ESC，yum install rsync就ok了。 二、配置rsync服务1.先建立个同步数据的帐号123groupadd rsyncuseradd -g rsync -s /sbin/nologin -d /home/rsync rsyncpasswd rsync 2.rsyncd.conf1vim /etc/rsyncd.conf 123456789101112131415161718secrets file = /etc/rsyncd.secretsmotd file = /etc/rsyncd.motdread only = yeslist = yesuid = rsync /*同步用的帐号，此账户对模块要有相应的权限*/gid = rsync /*同步用的帐号组*/hosts allow = 10.172.222.246 #哪些电脑可以访问rsync服务，多个ip用空格隔开hosts deny = 192.168.100.0/24 #哪些电脑不可以访问rsync服务max connections = 0 /*最大连接数，0表示无限制*/log file = /var/log/rsyncd.logpid file = /var/run/rsyncd.pidlock file = /var/run/rsync.lock#再定义rsync目录[www]comment = www 's directory from 10.171.88.115path = /alidata/www /*模块的路径*/chroot = falseauthusers=rsync #不设置代表客户端同步无需密码&lt;/pre&gt; （注：以上注释部分真实使用时请去掉，不去掉会有语法错误,下同！！！） 3.rsyncd.secrets1vi /etc/rsyncd.secrets rsyncd.secrets是存储rsync服务的用户名和密码的，它是一个明文的文本文件，下面给出一个rsyncd.secrets文件的例子： 1rsync:abcde 因为rsyncd.secrets存储了rsync服务的用户名和密码，所以非常重要，因此文件的属性必须设为600，只有所有者可以读写：1chmod 600 /etc/rsyncd.secrets 4.rsyncd.motd1vi /etc/rsyncd.motd rsyncd.motd记录了rsync服务的欢迎信息，你可以在其中输入任何文本信息，如：1Welcome to use the rsync services! 5.services1vi /etc/services services并不是rsync的配置文件，这一步也可以不做。而修改了services文件的好处就在于系统知道873端口对就的服务名为rsync。修改services的方法就是确保services中有如下两行，没有的话就自行加入：12rsync 873/tcp # rsyncrsync 873/udp # rsync 6./etc/xinetd.d/rsync1vi /etc/xinetd.d/rsync 建立一个名为/etc/xinetd.d/rsync文件，输入以下内容：12345678910service rsync&#123;disable = nosocket_type = streamwait = nouser = rootserver = /usr/local/rsync/bin/rsync #写你rsync的运行文件目录server_args = - -daemonlog_on_failure += USERID&#125; 保存后，就可以运行rsync服务了。 7.如果有防火墙 rsync服务器和防火墙，关掉对rsync的屏蔽1iptables -A INPUT -p tcp -m state --state NEW -m tcp - -dport 873 -j ACCEPT 8.运行rsync 输入以下命令： （可能xinetd 没安装 yum安装一下就行）1/etc/rc.d/init.d/xinetd reload 这样rsync服务就在这台机器上(10.171.88.115)运行起来了，接下来就是如何来使用它了。 如果想开机自启动1vi /etc/rc.d/rc.local 将/etc/rc.d/init.d/xinetd reload或者service xinetd start加进去就可以了 三、rsync客户端配置1.安装rsync，无需启动rsync服务，因为它又不当rsync服务器2.1rsync -avz --progress --delete rsync@10.171.88.115::www /alidata/www 有设置权限（服务端目录设置时有authusers:xxxxx）的需要输入密码，如果没有就立即同步啦 如果嫌每次输入密码麻烦，新建一个密码文件，#touch /etc/rsync.secret 编辑1vim /etc/rsync.secret 1abcde #里面写密码就行了 再1chmod 600 /etc/rsync.secret 然后同步时命令就可以这样写：1rsync -avz --progress --delete --password-file=/etc/rsync.secret rsync@10.171.88.115::www /alidata/www 3.crontb实现自动同步 先新建一个sh文件12touch /root/rsync.shvim /root/rsync.sh 里面输入：12!/bin/bashrsync -avz --progress --delete --password-file=/etc/rsync.secret rsync@10.171.88.115::www /alidata/www &gt;&gt; /root/rsync-crontablog.txt （这里把输出的结果写到了一个txt文件里） ok!下面写crontb文件：12crontb -e */1 7-23 * * * /root/rsync.sh 让它7点到晚上23点每隔一分钟同步 修改文件权限：1chmod 755 /root/rsync.sh 大功告成！！！(注：以上是客户端向服务端取文件，你也可以从客户端向SERVER端上传文件，那就要反过来，1个服务器做客户端，n台服务器做server端，也就是要配很多次server端的配置，有兴趣的同学可以尝试一下。另外我这里用的是crontab进行最快一分钟一次有点延时的实时同步，大家可以尝试rsync+inotify进行真正的实时同步，推荐博客：http://blog.chinaunix.net/xmlrpc.php?r=blog/article&amp;uid=11840697&amp;id=3890795)","categories":[],"tags":[{"name":"linux","slug":"linux","permalink":"http://jayzchen.com/tags/linux/"},{"name":"rsync","slug":"rsync","permalink":"http://jayzchen.com/tags/rsync/"},{"name":"crontab","slug":"crontab","permalink":"http://jayzchen.com/tags/crontab/"},{"name":"inotify","slug":"inotify","permalink":"http://jayzchen.com/tags/inotify/"}]},{"title":"抽奖活动业务逻辑的处理","slug":"lottery-draw-simple-algorithm","date":"2015-03-27T04:17:59.000Z","updated":"2017-04-10T14:46:18.000Z","comments":true,"path":"2015/03/27/lottery-draw-simple-algorithm/","link":"","permalink":"http://jayzchen.com/2015/03/27/lottery-draw-simple-algorithm/","excerpt":"注意：以下方法只适合低并发的抽奖活动，因为我们直接去操作了数据库，如果是高并发的活动可以尝试Redis。","text":"注意：以下方法只适合低并发的抽奖活动，因为我们直接去操作了数据库，如果是高并发的活动可以尝试Redis。 数据表结构如下：12345678910111213141516171819202122232425262728293031323334353637CREATE TABLE `shakecard_card` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `card_id` varchar(120) NOT NULL COMMENT '微信卡券ID', `appid` char(32) NOT NULL COMMENT '公众号的appid', `status` tinyint(3) unsigned NOT NULL DEFAULT '1' COMMENT '卡券是否用来摇奖，0代表否，1代表是', `prob` int(10) unsigned NOT NULL COMMENT '奖品概率（概率=当前数/总和)', `activity_id` varchar(100) DEFAULT '', `shakecard_id` varchar(100) NOT NULL, `title` varchar(100) DEFAULT NULL COMMENT '卡券标题', PRIMARY KEY (`id`), KEY `appid` (`appid`), KEY `status` (`status`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='卡券表，这里就是指奖品表';CREATE TABLE `shakecard_rid_cookie` ( `id` bigint(10) unsigned NOT NULL AUTO_INCREMENT, `rid` char(32) NOT NULL COMMENT '一个随机不重复的数', `mp_user_id` int(10) unsigned DEFAULT NULL COMMENT '公众号用户中间表id', `activity_id` varchar(100) NOT NULL DEFAULT '' COMMENT '活动id', `today_shake_count` int(10) unsigned NOT NULL COMMENT '今天的摇奖次数', `total_shake_count` int(10) unsigned NOT NULL COMMENT '总共的摇奖次数', PRIMARY KEY (`id`), KEY `mp_user_id` (`mp_user_id`), KEY `today_shake_count` (`today_shake_count`), KEY `rid` (`rid`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='cookie和openid对应表';CREATE TABLE `shakecard_record` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `mp_user_id` int(10) unsigned NOT NULL COMMENT '公众号用户中间表id', `status` tinyint(3) unsigned NOT NULL COMMENT '是否中奖,0代表未中,1代表中', `card_id` int(11) NOT NULL COMMENT '获得奖券的id', `action_time` datetime NOT NULL COMMENT '摇一摇的时间', PRIMARY KEY (`id`), KEY `action_time` (`action_time`), KEY `mp_user_id` (`mp_user_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='记录表'; 主要代码如下,在本例子中微信卡券就是一种奖品。。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?php/****************************抽奖的概率算法*****************************/function get_rand($proArr) &#123; $result = ''; //概率数组的总概率精度 $proSum = array_sum($proArr); //概率数组循环 foreach ($proArr as $key =&gt; $proCur) &#123;//$proCur的值为100,200,300,400 $randNum = mt_rand(1, $proSum); //$randNum位1~1000的一个随机数 if ($randNum &lt;= intval($proCur)) &#123; //如果这个随机数小于等于100 $result = $key; break; &#125; else &#123; $proSum -= intval($proCur); &#125; &#125; unset ($proArr); return $result;&#125;//首先查看该用户摇的次数是否已满，如果满了直接返回前端已满的状态，这就不举例了// 为了防止用户中奖的数量大于库存需要做些安全上的处理，我这里用的锁表，也可以用事务。。// *********************// 从下面开始 到执行 UNLOCK TABLES 之间操作的所有表都需要在下面一行加上 \", `表名` WRITE\"// *********************$dsn = 'mysql:dbname=testdb;host=127.0.0.1';$user = 'dbuser';$password = 'dbpass';$db = new PDO($dsn, $user, $password);$db-&gt;exec(\"LOCK TABLES `shakecard_card` WRITE,`shakecard_record` WRITE,`shakecard_rid_cookie` WRITE\");//查询出奖品的数据$card_data = array(array(),array());//得到一个二维数组$arr = array();$win_prob = 0;foreach ($card_data as $key =&gt; $val) &#123; $arr[$key] = intval($val['prob']); $win_prob += intval($val['prob']);&#125;//增加一个未中奖$arr[] = 100 - $win_prob;$rid = get_rand($arr); //根据概率获取奖项idif($rid === count($arr) - 1)&#123;//未中奖 $status = 0; $card_id = ''; $json_data = array( 'status' =&gt; $status, 'card_id' =&gt; $card_id, );&#125;else&#123; $result = $card_data[$rid]; //中奖项array $status = 1; $card_id= $result['card_id']; //返回数据 $json_data = array( 'status' =&gt; $status, 'card_id' =&gt; $card_id, );&#125;//存取数据到rid_cookie表,摇的数量增加$sql = \"UPDATE `shakecard_rid_cookie` SET `today_shake_count`=`today_shake_count`+1,`total_shake_count`=`total_shake_count`+1 WHERE `mp_user_id`='$mp_user_id'\";$res = $db-&gt;exec($sql);/******************存取抽奖记录*********************/$sql = \"INSERT INTO `shakecard_record` (`mp_user_id`,`card_id`,`status`,`action_time`) VALUES('$mp_user_id','$card_id','$status','$datetime')\";$res = $db-&gt;exec($sql);// [cc] 解锁表$db-&gt;exec(\"UNLOCK TABLES\");//前端ajax请求，输出json结果echo json_encode($json_data);","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"http://jayzchen.com/tags/PHP/"},{"name":"mysql","slug":"mysql","permalink":"http://jayzchen.com/tags/mysql/"}]}]}